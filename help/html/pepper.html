<h1 id="pepper-systems">Pepper Systems</h1>
<h2 id="overview">Overview</h2>
<p><em>Pepper</em> is a DNA circuit compiler developed by Shawn Ligocki in Erik Winfree's group at Caltech. It assists DNA programmers in building DNA computers by providing a templating language for specifying generic components and interfacing with state of the art designers and kinetic simulators to create and test sequences. Much like <a href="dynamic">DyNAMiC</a>, it can be used to design generic components and to</p>
<p>Pepper systems are comprised of <em>components</em> and <em>systems</em>. Components are re-usable &quot;building blocks,&quot; which can be composed together to form systems. The rest of this documentation was written by Shawn Ligocki, and describes the syntax for Pepper component and system files.</p>
<h2 id="pepper-file-syntax">Pepper File syntax</h2>
<h3 id="pepper-components">Pepper Components</h3>
<p>A component file (name.comp) contains the specification for a single component in a DNA system (like an AND gate or a threshold, etc.). It specifies the secondary structure, kinetic and sequence constraints for that component. System files are used to connect together components.</p>
<p>The component syntax is based on Joe Zadeh's design specification syntax.</p>
<h4 id="comments">Comments</h4>
<p>The pound sign (#) denotes that the rest of the line is a comment (python/sh style comments):</p>
<p><code>   # This is a comment</code></p>
<p>Comments may appear on their own lines or after a command, like so:</p>
<p><code>   declare component And22: x + y -&gt; s + c  # This is the function declaration</code></p>
<h4 id="component-declaration">Component Declaration</h4>
<p>In the spirit of Matlab's first line declarations, each component needs to have a declaration statement at the first line of code. Syntax:</p>
<p><code>      declare component </code><name><code>: </code><inputs><code> -&gt; </code><outputs></p>
<p>For example:</p>
<p><code>   declare component And22: x + y  -&gt;  s + c</code></p>
<p>The <inputs> and <outputs> are '+' separated lists of sequences that will be defined and used below in the specification. These sequences will be constrained on the system level and so usually represent the recognition regions of the inputs and outputs. Waste byproduct will generally not be represented here, because it will not be constrained on the system level.</p>
<p><name> should be the same as the base name of the component file (i.e. this file should be HalfAdder.comp).</p>
<h4 id="sequences">Sequences</h4>
<p>In order to constrain some regions/subdomains of some strands to be complementary to regions on other strands we define sequence regions:</p>
<p><code>   sequence </code><name><code> = </code><constraints><code> : </code><length></p>
<p>For example:</p>
<p><code>   sequence x = &quot;6N S 13N S&quot; : 21</code></p>
<p>''The total length constraint is optional; if you don't want it, omit it and the colon.</p>
<p>We include the (redundant) length input for quick error checking as complex constraints can be easily misnumbered. In addition one wildcard (?) may be used instead of a number, to imply (make this as large as possible to fit the specified total length. For example:</p>
<p><code>   sequence dx = &quot;S ?N S&quot; : 15</code></p>
<p>is the same as:</p>
<p><code>   sequence dx = &quot;S 13N S&quot; : 15</code></p>
<p>Sequence region definitions may include previously defined regions, for example:</p>
<p><code>   # The toehold, clamp and data region of the carry-bit output</code></p>
<p><code>   sequence tc =  &quot;6N&quot; :  6</code></p>
<p><code>   sequence cc =  &quot;1S&quot; :  1</code></p>
<p><code>   sequence dc = &quot;29N&quot; : 29</code></p>
<p><code>   # We combine them into a single label</code></p>
<p><code>   sequence  c = tc1 cc1 dc1 : 36</code></p>
<p>So now, for example:</p>
<p><code>   c* = dc* cc* tc*</code></p>
<p>We use quotes for nucleotide constraints so that we can distinguish them from other sequence names and group them (each pair of quotes denotes one domain).</p>
<h4 id="strands">Strands</h4>
<p>Strands represent individual strand of DNA in the system. The syntax is:</p>
<p><code>   strand </code><name><code> = </code><list of sequences and explicit constraints><code> : </code><length></p>
<p>For example:</p>
<p><code>   strand C = &quot;?N&quot; c : 44</code></p>
<p>The &quot;?N&quot; is an explicit constraint. First of all, it uses the wildcard, so it fills the remaining space on the left. Furthermore, since it is never declared as a sequence it will be constrained only by what it is forced to bind to. The idea is that you have a data region of the strand and some other regions that you're required to have, but don't want to name.</p>
<h4 id="structures">Structures</h4>
<p>Now we glue the strands together to make multi-stranded (or single-stranded) structures:</p>
<p><code>   structure </code><name><code> = </code><list of strands><code> : </code><secondary structure></p>
<p>So continuing the above example:</p>
<p><code>   structure Gate = X + C + S + Y : U6 H15(+ H15(U29 + U14 H15(+)))</code></p>
<p>using [Joe Zadeh's (H)elix (U)npaired notation](Joe Zadeh's (H)elix (U)npaired notation &quot;wikilink&quot;) or, say</p>
<p><code>   structure Gate = X + C + S + Y : 6. 15( + 15( 29. + 14. 15( + 45)</code></p>
<p>in a sort of shorthand dot-paren notation (where each number is a multiplier on the symbol following it).</p>
<p>By default it is assumed that you want to optimize the thermodynamics of the structure to be as close to the specified secondary structure as possible. If not, you can tell the compiler not to optimize a specific structure. For example:</p>
<p><code>   structure [no-opt] Gate = X + C + S + Y : U6 H15(+ H15(U29 + U14 H15(+)))</code></p>
<p>This can be useful for two reasons. First, you may with to impose base-pairing constraints but don't want thermodynamic optimization, for example, because you know this structure is not the MFE structure. Second, you may want the compiler to know that these strands should be grouped together as a complex, but the intended complex has psuedoknots that cannot (yet) be properly expressed in Pepper.</p>
<p>Alternatively for limited optimization:</p>
<p><code>   structure [10nt] Gate = X + C + S + Y : U6 H15(+ H15(U29 + U14 H15(+)))</code></p>
<p>This aims to be within 10 nucleotides of the specified structure, on average. Note that how these parameters are interpreted is up to the back-end sequence designer. E.g. Zadeh's designer will try to minimize the average number of incorrect nucleotides; another designer might want the MFE structure to be within 10 nucleotides; the SpuriousC designer could use the parameter for some kind of weighting, but currently doesn't.</p>
<p>We can also specify the secondary structure on the domain level:</p>
<p><code>   structure Gate = X + C + S + Y : domain .(+(.+.(+)))</code></p>
<p>assuming, for example, that the strands had been defined as</p>
<p><code>   strand X = toe_x data_x</code></p>
<p><code>   strand C = carry &quot;29N&quot;</code></p>
<p><code>   strand S = &quot;14N&quot; sum</code></p>
<p><code>   strand Y = sum* carry* data_x*</code></p>
<p>Here each dot-paren represents an entire domain.</p>
<h4 id="kinetics">Kinetics</h4>
<p>Now all we have left is to explain the desired kinetics, what structures will interact and what will they produce:</p>
<p><code>   kinetic </code><input structures><code> -&gt; </code></p>
<output structures>
<p>So if we're working with the half adder, we might have:</p>
<p><code>   kinetic inX + Gate        -&gt;  waste_X + inter_G</code></p>
<p><code>   kinetic inY + inter_Gate  -&gt;  waste_Y + outS + outC</code></p>
<p>I might allow some optional parameters to fine tune these, maybe specifying fuzzy states or desired speed of reactions.</p>
<h4 id="examples">Examples</h4>
<ul>
<li><a href="DNA%20compiler/And22.comp" title="wikilink">DNA compiler/And22.comp</a></li>
</ul>
<h3 id="pepper-systems-1">Pepper Systems</h3>
<p>A system file (name.sys) contains a specification for the connectivity of <a href="DNA%20compiler/component%20syntax" title="wikilink">components</a> in a DNA system. It specifies each component and and ties their signal sequences together. A system may be used as a component in a larger system.</p>
<h4 id="comments-1">Comments</h4>
<p>The pound sign (#) denotes that the rest of the line is a comment (python/sh style comments): # This is a comment Comments may appear on their own lines or after a command, like so:</p>
<p><code>   import And22  # Half adder is used in the first layer only</code></p>
<h4 id="system-declaration">System Declaration</h4>
<p>In the spirit of Matlab's first line declarations, each system needs to have a declaration statement at the first line of code. Syntax:</p>
<p><code>   declare system </code><name><code>: </code><inputs><code> -&gt; </code><outputs></p>
<p>For example:</p>
<p><code>   declare system HalfAdder: x0 + y0  -&gt;  s0 + c1</code></p>
<p>The <inputs> and <outputs> are '+' separated lists of sequences that will be constrained to components below.</p>
<p>These are used if this is a system being used as a component. However, for top-level systems, we will not have inputs and outputs and so</p>
<p><name> should be the same as the base name of the component file (i.e. this file should be HalfAdder.comp).</p>
<h4 id="imports">Imports</h4>
<p>In order to use a component file you must import it first (python-style). Syntax:</p>
<p><code>   import </code><component name> <code>For example:</code></p>
<p><code>   import And22</code></p>
<p>You may import from a different directory/name than the name you use in the file. For example:</p>
<p><code>   import Georg0711/Parallel_And22 as And22</code></p>
<p>which would import from the component file 'Parallel_And22.comp' from the directory 'Georg0711/', but still use the name And22 in the specification.</p>
<h4 id="components">Components</h4>
<p>This is the meat of the circuit file. You must make one statement for each component in the DNA system specifying the input and output sequences. The syntax is:</p>
<p><code>   component </code><name><code> = </code><component name><code>: </code><list of input sequences><code> -&gt; </code><list of output sequences></p>
<p>for example</p>
<p><code>   component G0_01 = And22: nx0 + y0  -&gt;  s0 + nc1</code></p>
<p>Note: Components <strong>may</strong> have 0 inputs or 0 outputs (or even both, if you can find that useful). Example:</p>
<p><code>   component DNS0 = Detector: ns0 -&gt;</code></p>
<p>Is a 'ns0' detector. It will activate if ns0 is input but doesn't produce any outputs for downstream gates.</p>
<h4 id="examples-1">Examples</h4>
<ul>
<li><a href="DNA%20compiler/Half%20Adder" title="wikilink">DNA compiler/Half Adder</a></li>
<li><a href="DNA%20compiler/Two-Bit%20Adder" title="wikilink">DNA compiler/Two-Bit Adder</a></li>
</ul>
<h2 id="pepper-intermediate-language-pil">Pepper Intermediate Language (PIL)</h2>
