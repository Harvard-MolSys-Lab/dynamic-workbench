<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='App-usr-nodal-ws-objects-BuildManager'>/**
</span> * Manages serializing a graphical nodal system to DyNAML or TerseML and then
 * compiling to domains with either engine
 */
Ext.define(&quot;App.usr.nodal.ws.objects.BuildManager&quot;, {
	extend : 'Workspace.objects.Object',
	errorClsName: 'dynaml-error-message',
	statics: {
		dynaml: {
			domainProperties: ['name', 'identity','role',],
			nodeProperties: ['name','motif','polarity'],
			motifProperties: ['name','dynaml'],
		},
	},
	constructor : function() {
		this.callParent(arguments);
		this.workspace.buildManager = this;
		this.nodes = [];
		this.workspace.on('create',this.onCreate,this);
		this.workspace.on('destroy',this.onDestroy,this);
		this.addEvents('needsrebuild','beforerebuild','rebuild','error');
		
		this.on('needsrebuild',this.buildRealtime,this,{
			buffer: 1000
		});
		
	},
	// render: function() {
		// this.errorEl = Ext.get(Ext.core.DomHelper.append(this.workspace.getContainerEl(),{
	        // cls: this.errorClsName,
	    // }));
	    // this.errorEl.hide();
	// },
	// showError: function(message) {
		// this.errorEl.alignTo(this.workspace.getEl(),'tl-tl');
		// var size = this.workspace.getVisibleSize();
		// this.errorEl.setWidth(size.width);
		// this.errorEl.update(message);
		// this.errorEl.slideIn('t', {duration: 300, easing:'easeOut'});
	// },
	onCreate: function(obj) {
		if(!obj) return;
		if(obj.isWType('App.usr.nodal.ws.objects.Node')) {
			this.nodes.push(obj);
			_.each(App.usr.nodal.ws.objects.BuildManager.dynaml.nodeProperties,function(prop) {
				obj.on('change:'+prop,this.needsRebuild,this);
			},this);
			this.needsRebuild();
		} else if (obj.isWType('App.usr.nodal.ws.objects.Complement')){
			this.needsRebuild();
		} else if (obj.isWType('App.usr.nodal.ws.objects.Motif')) {
			this.needsRebuild();
			
			_.each(App.usr.nodal.ws.objects.BuildManager.dynaml.motifProperties,function(prop) {
				obj.on('change:'+prop,this.needsRebuild,this);
			},this);
		}
	},
	onDestroy: function(obj) {
		if(!obj) return;
		if(obj.isWType('App.usr.nodal.ws.objects.Node')) {
			this.nodes = _.without(this.nodes,obj);

			_.each(App.usr.nodal.ws.objects.BuildManager.dynaml.nodeProperties,function(prop) {
				obj.un('change:'+prop,this.needsRebuild,this);
			},this);
			this.needsRebuild();
		} else if (obj.isWType('App.usr.nodal.ws.objects.Complement')){
			this.needsRebuild();
		} else if (obj.isWType('App.usr.nodal.ws.objects.Motif')) {
			this.needsRebuild();
			
			_.each(App.usr.nodal.ws.objects.BuildManager.dynaml.motifProperties,function(prop) {
				obj.un('change:'+prop,this.needsRebuild,this);
			},this);
		}
	},
	needsRebuild: function() {
		this.fireEvent('needsrebuild');
	},
	buildRealtime: function() {
		try {			
			
		var dynaml = this.serializeDynaml();
		this.lastDynaml = JSON.parse(JSON.stringify(dynaml));
		
			
<span id='App-usr-nodal-ws-objects-BuildManager-event-beforerebuild'>		/**
</span>		 * @event beforerebuild
		 * Fires before a rebuild occurs
		 * @param {App.usr.nodal.ws.objects.BuildManager} buildManager
		 * @param {Object} dynaml
		 */
		this.fireEvent('beforerebuild',this,dynaml);
		var lib;
			lib = App.dynamic.Compiler.compileLibrary(dynaml);
			this.lastLibrary = lib;
<span id='App-usr-nodal-ws-objects-BuildManager-event-rebuild'>			/**
</span>			 * @event rebuild
			 * Fires upon successful rebuild of a system
			 * @param {App.usr.nodal.ws.objects.BuildManager} buildManager
			 * @param {App.dynamic.Library} library
			 */
			this.fireEvent('rebuild',this,lib);
			
			// Match custom motifs in the DyNAML to their corresponding objects in the library
			var customMotifs = _.chain(dynaml.motifs || []).map(function(motif) {
				return _.find(lib.motifs, function(m) { return m.name == motif.name });
			}).compact().value();
			
			// Sync new custom motifs with the store
			this.syncCustomMotifStore(customMotifs);
			
			// Hide error proxies
			_.each(this.workspace.getAllObjects(),function(obj) {
				if(obj.isWType('App.usr.nodal.ws.objects.Node')) {
					obj.hideError();
				}
			})
			
		} catch(e) {
			if(e.nodes) {
				_.each(e.nodes,function(node) {
					var workspaceNode = this.findWorkspaceObject('node',node);
					if(workspaceNode) {
						workspaceNode.highlightError();
					} 
				},this);
			}
			if(e.ports) {
				_.each(e.ports,function(port) {
					var workspacePort = this.findWorkspaceObject('port',port);
					if(workspacePort) {
						workspacePort.highlightError();
					}
				},this);
			}
			//this.showError(e.message);
<span id='App-usr-nodal-ws-objects-BuildManager-event-error'>			/**
</span>			 * @event error
			 * Fires upon an error during a real-time build
			 * @param {String} msg
			 * @param {App.dynamic.DynamlError} e
			 */
			this.fireEvent('error',e.message,e);
			this.lastError = e;
		}
		
	},
<span id='App-usr-nodal-ws-objects-BuildManager-method-syncCustomMotifStore'>	/**
</span>	 * Synchronizes #customMotifStore with the passed array of 
	 * {@link App.dynamic.Motif motifs}. If there are new motifs `motifs`, but 
	 * not in #customMotifStore, they are added. If there are motifs in 
	 * `motifs` with corresponding names in #customMotifStore, they are updated
	 * in the store. 
	 * @param {App.dynamic.Motif[]} motifs
	 */
	syncCustomMotifStore: function(motifs, clobber) {
		clobber = clobber || false;
		_.each(motifs,function(motif) {
			var rec = this.customMotifStore.findRecord('number',motif.getName());
			if(rec) {
				rec.set('spec',motif);
			} else {
				this.customMotifStore.add({
					number: motif.getName(),
					spec: motif
				})
			}
		},this);
	},
	
<span id='App-usr-nodal-ws-objects-BuildManager-method-findWorkspaceObject'>	/**
</span>	 * Attempts to locate an {@link Workspace.object.Object object} in the 
	 * {@link #workspace workspace} corresponding to a name, config object, or
	 * DyNAML object
	 * @param {String} type Kind of object for which to search; one of: `node`, `port`, or `connection`
	 * @param {App.dynamic.Node/App.dynamic.Domain/App.dynamic.Connection/Object/String} handle One of these many data type which could be used to identify a DyNAML object 
	 * @return {Mixed} workspaceObject The Workspace.objects.Object representing `handle`, or `null` if none was found. 
	 */
	findWorkspaceObject: function(type,obj) {
		var name;
		if(obj &amp;&amp; obj.getName) {
			name = obj.getName();
		} else if (_.isObject(obj) &amp;&amp; obj.name) {
			name = obj.name;
		} else if (_.isString(obj)) {
			name = obj;
		}
		
		if(name) {	
			switch (type) {
				case 'node':		
					return this.workspace.findObjectBy(function(obj) {
						return obj.isWType('App.usr.nodal.ws.objects.Node') &amp;&amp; (obj.get('name') == name);
					});
				case 'connection':
					return null
				case 'port':
					return false;
				case 'motif':
					return this.workspace.findObjectBy(function(obj) {
						return obj.isWType('App.usr.nodal.ws.objects.Motif') &amp;&amp; (obj.get('name') == name);
					});
			}		
		} else { 
			return null; 
		}
	},
	getRealtime: function(type,name,property) {
		if(this.lastLibrary) {
			
		switch (type) {
			case 'strand':
				var strand = this.lastLibrary.getStrand(name);
				if(!strand) return null;
				switch (property) {
					case 'this':
						return strand;
					case 'domains':
						return strand.getDomains();
					case 'polarity':
						return strand.getPolarity();
					case 'absolutePolarity': 
						return strand.getAbsolutePolarity();
					case 'dynaml':
						return (this.lastDynaml &amp;&amp; this.lastDynaml.strands) ? _.find(this.lastDynaml.nodes,function(x) { return x.name == name }) : false
						break;
					default:
						return strand[property]; 
				}
				break;
			case 'node':
				var node = this.lastLibrary.getNode(name);
				if(!node) return null;
				switch (property) {
					case 'this':
						return node;
					case 'domains':
						return node.getDomains();
					case 'strands':
						return node.getStrands();
					case 'polarity':
						return node.getPolarity();
					case 'dynaml':
						return (this.lastDynaml &amp;&amp; this.lastDynaml.nodes) ? _.find(this.lastDynaml.nodes,function(x) { return x.name == name }) : false
						break;
					default:
						return node[property]; 
				}
				break;
			case 'motif':
				var motif = this.lastLibrary.getMotif(name);
				if(!motif) return null;
				switch (property) {
					case 'this':
						return motif;
					
					case 'dynaml':
						return (this.lastDynaml &amp;&amp; this.lastDynaml.motifs) ? _.find(this.lastDynaml.motifs,function(x) { return x.name == name }) : false
						break;
					default:
						return node[property]; 
				}
				break;
		}
		} else { return null; }
	},
	nodeIndex: 0,
<span id='App-usr-nodal-ws-objects-BuildManager-method-getNextNodeName'>	/**
</span>	 * Returns the next unique node name
	 */
	getNextNodeName: function() {
		var nextName;
		do {
			this.nodeIndex++;
			nextName = &quot;n&quot;+this.nodeIndex;
		} while(!!this.workspace.findObjectBy(function(obj) { return obj.get('name') == nextName; }));
		return nextName;
	},
	motifIndex: 0,
<span id='App-usr-nodal-ws-objects-BuildManager-method-getNextMotifName'>	/**
</span>	 * Returns the next unique motif name
	 */
	getNextMotifName: function() {
		var nextName;
		do {
			this.motifIndex++;
			nextName = &quot;c&quot;+this.motifIndex;
		} while(!!this.workspace.findObjectBy(function(obj) { return obj.get('name') == nextName; }));
		return nextName;
	},
<span id='App-usr-nodal-ws-objects-BuildManager-method-buildDynaml'>	/**
</span>	 * Build a DyNAML library for a collection of {@link Workspace.objects.Object objects};
	 * these should generally be a mix of {@link App.usr.nodal.ws.objects.Node nodes},
	 * {@link App.usr.nodal.ws.objects.Motif motifs}, and {@link App.usr.nodal.ws.objects.Complement complements}.
	 * 
	 * @param {App.usr.nodal.ws.objects.Node[]/App.usr.nodal.ws.objects.Motif[]/App.usr.nodal.ws.objects.Complement[]} objects
	 * 
	 * @param {Boolean} [fromMotif=false] 
	 * True if we're compiling a library from children of a motif and should therefore look for {@link App.usr.nodal.ws.objects.NodePort#exposure exposure} properties
	 */
	buildDynaml: function(objects,fromMotif) {
		var workspace = this.workspace;
		var imports = [], nodes = [], motifs = [], complements = {}, nodeNameMap = {}, motifMap = {};
		fromMotif = fromMotif || false;

		// Sort through passed-in objects, picking out the interesting ones:
		_.each(objects,function(obj) {
			if(obj.isWType('App.usr.nodal.ws.objects.Node')) {
				nodeNameMap[obj.get('name')] = obj;
				nodes.push(obj);

				if(obj.get('motif')) {
					imports.push(obj.get('motif'));
				}
			} else if(obj.isWType('App.usr.nodal.ws.objects.Complement')) {
				var leftPort = obj.get('leftObject'), leftNode, leftNodeId;
				if(leftPort) {
					leftNode = leftPort.getParent();
				} else {
					return;
				}
				if(leftNode) {
					leftNodeId = leftNode.getId();
				} else {
					return;
				}
				if(!complements[leftNodeId])
					complements[leftNodeId] = [];

				complements[leftNodeId].push(obj);
			} else if(obj.isWType('App.usr.nodal.ws.objects.Motif')) {
				
				// Build a hash mapping motif names to App.usr.nodal.ws.objects.Motif objects
				motifMap[obj.get('name')] = obj;
				motifs.push(obj);
				
			} 
			/*
			else if(fromMotif &amp;&amp; obj.isWType(['App.usr.nodal.ws.objects.InputPort',
				'App.usr.nodal.ws.objects.OutputPort',
				'App.usr.nodal.ws.objects.BridgePort',
			])) {
				
			}
			*/
		});
		
		
		
		// Remove motifs which we've defined in the workspace
		imports = _.chain(imports).uniq().filter(function(name) {
			return !motifMap[name];
		}).map(function(name) {
			// Convert to the type of import objects accepted by DyNAMiC
			return {
				type : 'motif',
				name : name
			};
		}).value();
		
		// Build DyNAML objects for motifs
		motifs = _.chain(motifs).map(function(motif) {
			var nodes = motif.get('nodes');
			if(nodes &amp;&amp; nodes.length &gt; 0) {
				var lib = this.buildDynaml(motif.getChildren(),true);
				return _.reduce(App.usr.nodal.ws.objects.BuildManager.dynaml.motifProperties, function(memo, property) {
					if(motif.has(property)) {
						memo[property] = motif.get(property);
					}
					return memo;					
				},lib);
			} else if(motif.get('dynaml')) {
				var dyn;
				try {				
					dyn = jsonlint.parse(motif.get('dynaml'));
				} catch (e) {
					throw { message: [&quot;In motif&quot;,motif.get('name'),&quot;:\n&quot;,e.message].join(' ')}
				}
				return _.reduce(App.usr.nodal.ws.objects.BuildManager.dynaml.motifProperties, function(memo, property) {
					if(motif.has(property)) {
						memo[property] = motif.get(property);
					}
					return memo;					
				},dyn);
			}
		},this).compact().value();
		
		// Build DyNAML objects for nodes
		nodes = _.map(nodes, function(node) {
			var polarity = node.get('polarity');
			return {
				name : node.get('name'),
				motif : node.get('motif'),
				polarity : (isNaN(polarity) ? 0 : polarity),
				complementarities : _.map(complements[node.getId()] || [], function(complement) {
					return {
						source : complement.get('leftObject').get('name'),
						target : complement.get('rightObject').get('name'),
						node : complement.get('rightObject').get('parent').get('name')
					};
				}),
				domains : _.map(node.getChildren(), function(child, i) {
					// This is a bit cryptic; allow me to elucidate:
					
					// Match port objects
					if(child.isWType(['App.usr.nodal.ws.objects.InputPort',
						'App.usr.nodal.ws.objects.OutputPort',
						'App.usr.nodal.ws.objects.BridgePort'])) {
						
						// Iterate across the array of properties in the static member #dynaml.domainProperties
						// Check if the child has each one, if so, put it in the dynaml
						return _.reduce(App.usr.nodal.ws.objects.BuildManager.dynaml.domainProperties, function(memo, property) {
							if(child.has(property)) {
								memo[property] = child.get(property);
							}
							return memo;
							
						// Base case of _.reduce: a few properties which have defaults or are added conditionally:
						},{
							// If the child doesn't have a name, generate one.
							name : child.get('name') || 'p' + i,
							
							// If we're making dynaml from children of a motif, this domain may be &quot;exposed&quot;
							// outside the motif with an &quot;exposure&quot; property linking it to *another*
							// App.usr.nodal.ws.objects.NodePort object. We pull properties from that object
							// to put in the dynaml
							expose: fromMotif ? (function(exposed) { 
								return exposed ? {
									role: exposed.get('role'),
									name: exposed.get('name')
								} : null;
							})(child.get('exposure')) : null
						});
					}
					// if(child.isWType('App.usr.nodal.ws.objects.InputPort')) {
					// return {
					// name : child.get('name') || 'p'+i,
					// identity : child.get('identity')
					// }
					// } else if(child.isWType('App.usr.nodal.ws.objects.OutputPort')) {
					// return {
					// name : child.get('name') || 'p'+i,
					// identity : child.get('identity')
					// }
					// } else if(child.isWType('App.usr.nodal.ws.objects.BridgePort')) {
					// return {
					// name : child.get('name') || 'p'+i,
					// identity : child.get('identity')
					// }
					// }
				})
			};
		});
		return {
			'import' : imports,
			nodes : nodes,
			motifs: motifs,
			version: workspace.version,
		}
	},
	serializeDynaml : function() {
		return this.buildDynaml(this.workspace.getRootObjects());
	},
	serializeTerse : function() {
		var workspace = this.workspace;
		var nodes = [], complementarities = [], indexMap = {}, i = 1, out = [];
		workspace.objects.each(function(obj) {
			if(obj.isWType('App.usr.nodal.ws.objects.Node')) {
				indexMap[obj.getId()] = i;
				i++;

				nodes.push(obj);
			} else if(obj.isWType('App.usr.nodal.ws.objects.Complement')) {
				complementarities.push(obj);
			}
		});
		out.push(nodes.length.toString());

		var untitledCount = 0;
		Ext.each(nodes, function(obj) {
			var motif = obj.get('motif');
			if(isNaN(parseInt(motif))) {
				motif = parseInt(_.first(motif.match(/\d+/g)));
			} else {
				motif = parseInt(motif);
			}
			var row = [obj.get('name').replace(/\s/g, '_') || (&quot;Untitled_&quot; + (++untitledCount)), motif], complementaryPort, complementaryNode;
			obj.children.each(function(port) {
				if(port.isWType('App.usr.nodal.ws.objects.OutputPort') || port.isWType('App.usr.nodal.ws.objects.BridgePort')) {
					if(port.get('complementarity')) {
						complementaryPort = port.get('complementarity');
						if(complementaryPort.hasParent()) {
							complementaryNode = complementaryPort.get('parent');
							if(complementaryNode) {
								row.push(indexMap[complementaryNode.getId()]);
								return true;
							}
						}
					}
					row.push('0');
				}
			});
			out.push(row.join(' '));
		});
		return out.join('\n');
	},
	
<span id='App-usr-nodal-ws-objects-BuildManager-method-buildMotif'>	/**
</span>	 * Builds a node of the given motif type at the provided coordinates
	 * @param {String} type The name of the motif in App.usr.nodal.ws.objects.Motifs
	 * @param {Number} x
	 * @param {Number} y
	 * @returns {App.usr.nodal.ws.objects.Node} node
	 */
	buildMotif: function(spec,x,y) {
		//var spec = App.usr.nodal.ws.objects.Motifs[name], node;
		var node,name;
		//spec.serialize();
		if(spec) {
			spec = spec.serialize(); 
			spec.library = App.dynamic.Library.dummy(); 
			spec = new App.dynamic.Motif(spec);
			name = spec.name;
			//spec.serialize();
			node = this.workspace.createObject({
				wtype: 'App.usr.nodal.ws.objects.Node',
				x: x,
				y: y,
				motif: name,
				// dynaml: spec,
			});
			node.suspendLayout = true;
			_.each(spec.getDomains(), function(dom,i) {
				var port = _.clone(dom); 
				var cfg = {};
				if(_.isObject(port) &amp;&amp; App.usr.nodal.ws.objects.PortClasses[port.role]) {
					cfg.name = port.name;//'p'+(i+1);
					cfg.wtype = App.usr.nodal.ws.objects.PortClasses[port.role];
					cfg.stroke = App.dynamic.Compiler.getColor(port);
					cfg.segments = port.segments;
					//cfg.identity = port.name;
					// cfg.dynaml = port;
					cfg.role = port.role;
					node.adopt(this.buildPort(cfg));
				}
			},this);
			node.suspendLayout = false;
			node.doLayout();
		}
		return node;
	},
<span id='App-usr-nodal-ws-objects-BuildManager-method-buildPort'>	/**
</span>	 * Constructs a {@link Workspace.objects.nodal.NodePort port}
	 * @param {String/Object} config String name of a port class in App.usr.nodal.ws.objects.Ports or configuration object for a Workspace.objects.nodal.NodePort. 
	 */
	buildPort: function(config) {
		config || (config = {});
		if(_.isString(config)) {
			return this.workspace.createObject(App.usr.nodal.ws.objects.Ports[config]);
		} else {
			if(!config.name) {
				
			}
			return this.workspace.createObject(config);
		}
	}
	
}, function() {
	Workspace.reg('App.usr.nodal.ws.objects.BuildManager', App.usr.nodal.ws.objects.BuildManager);
	Workspace.regAlias('Workspace.objects.dna.BuildManager', 'App.usr.nodal.ws.objects.BuildManager');

})</pre>
</body>
</html>
