<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">Ext.define('Complex', {
	extend: 'Ext.data.Model',
	fields: [{
		name: 'id',
		type: 'int'
	}, {
		name: 'name'
	}, {
		name: 'polarity',
		type: 'int'
	}, {
		name: 'strands' // array
	}, {
		name: 'specs',
		// array
	}, {
		name: 'sequences',
		// array
	}, {
		name: 'structure'
	}, ],
	idgen: 'sequential',
	getDynaml: function(lib) {
		return lib.getNode(this.get('name'));
	},
	getStrands: function() {
		return this.get('strands');
	},
	getStructures: function() {
		var structures = this.get('structure') || '';
		return  _.map(structures.split('+'), function(s) {
			return s.trim();
		});
	},
	fixStructure: function(strandIndex,added,removed) {
		var structures = this.getStructures(),
			struct = structures[strandIndex];
		if(struct) {
			struct = struct.split('');
			for(var i=struct.length-1; i&gt;=0; i--) {
				if(removed.indexOf(i) != -1) {
					delete struct[i];
				}
				if(added.indexOf(i) != -1) {
					struct.splice(i,0,'.');
				}
			}
			structures[strandIndex] = _.compact(struct).join('');
			this.set('structure',structures.join('+'));
		}
	},
	proxy: 'memory',
});

Ext.define('Strand', {
	extend: 'Ext.data.Model',
	fields: [{
		name: 'id',
		type: 'int'
	}, {
		name: 'name'
	}, {
		name: 'polarity',
		type: 'int'
	}, {
		name: 'sequence'
	}, {
		name: 'domains'
	}, {
		name: 'spec'
	}, ],
	idgen: 'sequential',
	set: function(fieldName,newValue) {
		if(fieldName == 'spec') {
			if(newValue!=this.get('spec')) {
				this.updateCachedSpec(newValue);	
			}
		}
		this.callParent(arguments);
		
	},
	getDynaml: function(lib) {
		return lib.getStrand(this.get('name'));
	},
	diffSpec: function(spec) {
		var oldSpec = spec,
			newSpec = this.parsedSpec;
		var oldSegments = _.comprehend(oldSpec,function(dom) { return dom.segments; }),
			newSegments = _.comprehend(newSpec,function(dom) { return dom.segments; });
		var removed = _.difference(oldSegments,newSegments),
			added = _.difference(newSegments,oldSegments);
		var removedIndices = _.map(removed,function(seg) { return oldSegments.indexOf(seg)}),
			addedIndices = _.map(added,function(seg) { return newSegments.indexOf(seg)});			
		return {
			removed: removed,
			added: added,
			removedIndices: removedIndices, 
			addedIndices: addedIndices,
		}
	},
	updateCachedSpec: function(newValue,oldValue) {
		// if(newValue &amp;&amp; oldValue) {
		// 	var oldSpec = this.parsedSpec,
		// 		newSpec = App.dynamic.Compiler.parseDomainString(newValue);
		// 	var oldSegments = _.comprehend(oldSpec,function(dom) { return dom.segments; }),
		// 		newSegments = _.comprehend(newSpec,function(dom) { return dom.segments; });
		// 	var removed = _.difference(oldSegments,newSegments),
		// 		added = _.difference(newSegments,oldSegments);
		// 	var removedIndices = _.map(removed,function(seg) { return oldSegments.indexOf(seg)}),
		// 		addedIndices = _.map(added,function(seg) { return newSegments.indexOf(seg)});			

		// 	this.parsedSpec = App.dynamic.Compiler.parseDomainString(newValue, /*parseIdentifier*/ true);
		//} else 
		if(newValue) {
			this.parsedSpec = App.dynamic.Compiler.parseDomainOrSegmentString(newValue, /*parseIdentifier*/ true);
		} else {
			this.parsedSpec = App.dynamic.Compiler.parseDomainOrSegmentString(this.get('spec'), /*parseIdentifier*/ true);
		}
	},
	getParsedSpec: function() {
		if(!this.parsedSpec) {
			this.updateCachedSpec();
		}
		return this.parsedSpec;
	},
	getFlatSpec: function() {
		return _.comprehend(this.getParsedSpec(), function(dom) {
			return dom.segments
		});
	},
	proxy: 'memory',
})

Ext.define('Domain', {
	extend: 'Ext.data.Model',
	fields: [{
		name: 'name'
	}, ],
	// getDynaml: function(lib) {
	// return this.getStrand().getDynaml(lib).getDomain(this.get('name'));
	// }
})

Ext.define('Segment', {
	extend: 'Ext.data.Model',
	fields: [{
		name: 'identity'
	}, {
		name: 'sequence'
	}, {
		name: 'color',
	}],
});

Ext.define('App.ui.SegmentStore', {
	extend: 'Ext.data.Store',
	model: 'Segment',
	constructor: function() {
		this.callParent(arguments);
		this.on('update', function(segmentStore, rec, op, modifiedFieldNames) {
			if(modifiedFieldNames.indexOf('sequence') != -1) {
				this.updateSegmentMap(rec);
			}
			if(modifiedFieldNames.indexOf('color') != -1) {
				this.updateSegmentColorMap(rec);	
			}
		}, this);
		this.on('add', function(strandStore, recs, index) {
			this.updateSegmentMap(recs);
			this.updateSegmentColorMap(recs);
		}, this);
	},
	buildSegmentMap: function() {
		var segmentIds = this.getRange(),
			allSegments = [],
			segmentMap = {};

		// Build map of segment identities to sequences
		for(var i = 0; i &lt; segmentIds.length; i++) {
			var rec = segmentIds[i],
				seg = {
					identity: rec.get('identity'),
					sequence: rec.get('sequence')
				};
			allSegments.push(seg);
			segmentMap[seg.identity] = seg.sequence;
		}
		return segmentMap;
	},
	getSegmentMap: function() {
		if(this.segmentMap) {
			return this.segmentMap;
		} else {
			this.segmentMap = this.buildSegmentMap();
		}
	},
	getSegmentMapWithComplements: function() {
		var segmentMap = this.getSegmentMap();
		return DNA.hashComplements(segmentMap);
	},
	updateSegmentMap: function(rec) {
		if(rec &amp;&amp; this.segmentMap) {
			if(_.isArray(rec)) {
				for(var i = 0; i &lt; rec.length; i++) {
					this.segmentMap[rec[i].get('identity')] = rec[i].get('sequence');
				}
			} else {
				this.segmentMap[rec.get('identity')] = rec.get('sequence');
			}
		} else {
			this.segmentMap = this.buildSegmentMap();
		}
		return this.segmentMap;
	},
	buildSegmentColorMap: function() {
		var segmentIds = this.getRange(),
			segmentMap = {};

		// Build map of segment identities to sequences
		for(var i = 0; i &lt; segmentIds.length; i++) {
			var rec = segmentIds[i];
			segmentMap[rec.get('identity')] = rec.get('color');
		}
		return segmentMap;
	},
	getSegmentColorMap: function() {
		if(this.segmentColorMap) {
			return this.segmentColorMap;
		} else {
			this.segmentColorMap = this.buildSegmentColorMap();
		}
	},
	updateSegmentColorMap: function(rec) {
		if(rec &amp;&amp; this.segmentColorMap) {
			if(_.isArray(rec)) {
				for(var i = 0; i &lt; rec.length; i++) {
					this.segmentColorMap[rec[i].get('identity')] = rec[i].get('color');
				}
			} else {
				this.segmentColorMap[rec.get('identity')] = rec.get('color');
			}
		} else {
			this.segmentColorMap = this.buildSegmentColorMap();
		}
		return this.segmentColorMap;
	},
	getSegmentColorScale: function() {
		var me = this;
		return function segmentColorScale(_) {
			return me.segmentColorMap[_];
		};
	},
	getColorGenerator: function() {
		if(!this.segmentColors) {
			this.segmentColors = d3.scale.category20();
		}
		return this.segmentColors;
	},
	getColor: function(identity) {
		var gen = this.getColorGenerator();
		return gen(identity);
	},
	addSegment: function(length) {
		var segmentMap = this.getSegmentMap(),
			identity = _.max(_.map(_.keys(segmentMap), function(key) {
				return isNaN(+key) ? 0 : (+key);
			}));
		identity &lt; 0 ? (identity = 1) : identity+=1;

		return this.add({
			identity: identity,
			sequence: Array(length + 1).join('N'),
			color: this.getColorGenerator()(identity),
		});
	},
});

Ext.define('App.ui.StrandStore', {
	extend: 'Ext.data.Store',
	model: 'Strand',
	constructor: function() {
		this.callParent(arguments);
		if(this.segmentStore) {
			this.segmentStore.on('update', function(segmentStore, rec, op, modifiedFieldNames) {
				if(modifiedFieldNames.indexOf('sequence') != -1) {
					this.updateStrandSequences();
				}
			}, this);
		}
		this.on('update', function(segmentStore, rec, op, modifiedFieldNames) {
				if(modifiedFieldNames.indexOf('spec') != -1) {
					this.updateStrandSequence(rec);
				}
		},this)
	},
	updateStrandSequence: function updateStrandSequence (rec) {
		var segmentMap = this.segmentStore.getSegmentMap(),
		strand = rec,
		strandSpec = rec.getFlatSpec();
		strand.set('sequence',DNA.threadSegments(segmentMap,strandSpec));
	},
	updateStrandSequences: function() {
		var segmentMap = this.segmentStore.getSegmentMap(),
			strands = this.getRange();

		for(var i = 0; i &lt; strands.length; i++) {
			var strand = strands[i],
				strandSpec = strand.getFlatSpec();
			strand.set('sequence', DNA.threadSegments(segmentMap, strandSpec));
		}
	},
	getSegmentMap: function() {
		return this.segmentStore.getSegmentMap();
	},
	getSegmentMapWithComplements: function() {
		return this.segmentStore.getSegmentMapWithComplements();
	},
	addStrand: function() {
		var name = _.max(_.map(this.getRange(), function(rec) {
			var k = rec.get('name').match(/\d+/g);

			return (!!k &amp;&amp; k.length &gt; 0 &amp;&amp; !isNaN(k[0])) ? k : 0;
		}));
		name &lt; 0 ? (name = 0) : name;
		var existing;
		do {
			name+=1;
			existing = this.find('name',name);	
		} while (existing != -1)

		return this.add({
			name: 'n'+name,
			spec: '',
		});
	},
})

Ext.define('App.ui.ComplexStore', {
	extend: 'Ext.data.Store',
	model: 'Complex',
	constructor: function() {
		this.callParent(arguments);
		if(this.strandStore) {
			this.strandStore.on('update', function(segmentStore, rec, op, modifiedFieldNames) {
				if(modifiedFieldNames.indexOf('sequence') != -1 || modifiedFieldNames.indexOf('spec') != -1) {
					this.updateComplexes();
				}
			}, this);
		}
	},
	updateComplexes: function(changedStrand) {
		var strandSpecs = {},
			strandSeqs = {},
			strands = this.strandStore.getRange(),
			complexes = this.getRange();
		for(var i = 0; i &lt; strands.length; i++) {
			var strand = strands[i],
				name = strand.get('name');
			strandSpecs[name] = strand.get('spec');
			strandSeqs[name] = strand.get('seq');
		}

		var changedStrandName = changedStrand ? changedStrand.get('name') : null;
		for(var i = 0; i &lt; complexes.length; i++) {
			var complex = complexes[i],
				complexStrands = complex.get('strands'),
				spec = [],
				seqs = [],
				struct = null,
				diffSpec = null;
			for(var j = 0; j &lt; complexStrands.length; j++) {
				var strandName = complexStrands[j];
				
				// if(strandName == changedStrandName) {
				// 	var oldSpec = complex.get('spec')[j];
				// 	if(!diffSpec) {
				// 		diffSpec = changedStrand.diffSpec(oldSpec);
				// 	}

				// }
				spec.push(strandSpecs[strandName]);
				seqs.push(strandSeqs[strandName]);
			}
			complex.beginEdit();
			complex.set('spec', spec);
			complex.set('seqs', seqs);
			complex.endEdit();
		}
	},
	addComplex: function() {
		var name = _.max(_.map(this.getRange(), function(rec) {
			var k = rec.get('name').match(/\d+/g);

			return (!!k &amp;&amp; k.length &gt; 0 &amp;&amp; !isNaN(k[0])) ? k : 0;
		}));
		name &lt; 0 ? (name = 0) : name;
		var existing;
		do {
			name+=1;
			existing = this.find('name',name);	
		} while (existing != -1)

		return this.add({
			name: 'n'+name,
			strands: [],
			specs: [],
			struture: '',
		});
	},
});


Ext.define('App.ui.StrandPreviewGrid', {
	extend: 'Ext.view.View',
	cellWidth: 200,
	cellHeight: 200,
	itemSelector: 'div.complex-wrap',
	trackOver: true,
	overItemCls: 'x-view-over',
	multiSelect: false,
	singleSelect: true,

	autoScroll: true,
	paddingWidth: 6,
	paddingHeight: 14,

	nodeFillMode: 'segment', // 'identity', 'segment', 'domain'
	nodeStrokeMode: 'segment', // 'identity', 'segment', 'domain'
	lineStrokeMode: 'default',
	textFillMode: 'default',
	showBubbles: true,
	loopMode: 'linear',
	showBases : true,
	showIndexes : true,
	showSegments : true,


	initComponent: function() {
		this.strandPreviews = {};
		this.tpl = ['&lt;tpl for=&quot;.&quot;&gt;', '&lt;div style=&quot;border:solid 1px white;padding:4px;margin:10px;float:left;width:' + this.cellWidth + 'px;height:' + this.cellHeight + 'px;&quot; class=&quot;complex-wrap&quot;&gt;',
		//'&lt;span&gt;{name}&lt;/span&gt; = &lt;span&gt;{[values.strands.join(&quot; + &quot;)]}&lt;/span&gt; : &lt;span&gt;{structure}&lt;/span&gt;',
		'&lt;span style=&quot;position:absolute;&quot;&gt;{name}&lt;/span&gt;', '&lt;/div&gt;', '&lt;/tpl&gt;'].join(''),

		this.on('itemadd', this.addComplexes);
		this.on('itemupdate', this.updateComplex);
		this.on('itemremove', this.removeComplex);

		this.on('itemmouseenter', function(view, rec, el, e) {
			this.fireEvent('updateToolbar', el);
		}, this);
		
		this.segmentStore.on('update', function(segmentStore, rec, op, modifiedFieldNames) {
			if(modifiedFieldNames.indexOf('color') != -1) {
				this.refresh();
			}
		},this,{buffer: 100});

		this.callParent(arguments);
	},
<span id='global-method-getChart'>	/**
</span>	 * Returns a StrandPreview chart object
	 * @param  {Boolean} update
	 * True to force the chart to be updated with #cellHeight, #cellWidth, #nodeStrokeMode, etc. properties.
	 *
	 * @return {[type]}
	 */
	getChart: function(update) {
		update || (update = false);
		if(!this.chart || update) {
			this.chart = StrandPreview().width(this.cellWidth - this.paddingWidth).height(this.cellHeight - this.paddingHeight)
			.showBubbles(this.showBubbles)
			.showBases(this.showBases)
			.showIndexes(this.showIndexes)
			.showSegments(this.showSegments)
			.loopMode(this.loopMode)
			.nodeStrokeMode(this.nodeStrokeMode)
			.nodeFillMode(this.nodeFillMode)
			.lineStrokeMode(this.lineStrokeMode)
			.textFillMode(this.textFillMode);
			this.chart.segmentColors(this.getSegmentColorScale());

			//if(!!this.segmentColors) this.chart.segmentColors(this.segmentColors)
		}
		return this.chart;
	},
	updateChartProperties: function() {
		this.tpl = new Ext.XTemplate(['&lt;tpl for=&quot;.&quot;&gt;', '&lt;div style=&quot;border:solid 1px white;padding:4px;margin:10px;float:left;width:' + this.cellWidth + 'px;height:' + this.cellHeight + 'px;&quot; class=&quot;complex-wrap&quot;&gt;',
		//'&lt;span&gt;{name}&lt;/span&gt; = &lt;span&gt;{[values.strands.join(&quot; + &quot;)]}&lt;/span&gt; : &lt;span&gt;{structure}&lt;/span&gt;',
		'&lt;span style=&quot;font-weight:bold;&quot;&gt;{name}&lt;/span&gt;', '&lt;/div&gt;', '&lt;/tpl&gt;'].join(''));

		this.getChart(true);
		this.refresh();
	},
	refresh: function() {
		this.callParent(arguments);

		var me = this,
			nodes = [],
			records = me.store.getRange(),
			data = [],
			segmentMap = me.getSegmentMap();
		for(var i = 0; i &lt; records.length; i++) {
			var rec = records[i],
				dom = this.getNode(rec);

			if(dom) {
				nodes.push(dom);

				data.push({
					strands: _.map(rec.getStrands(), function(strandName) {
						return {
							name: strandName,
							domains: me.strandStore.findRecord('name', strandName).getParsedSpec()
						}
					}),
					structure: rec.get('structure'),
					sequences: segmentMap,
				});
			}
		}

		if(nodes.length &gt; 0) {
			// Configure chart prototype
			var chart = me.getChart();

			// Build selection and chart
			var nodeData = d3.selectAll(nodes).data(data).append('svg');
			this.preview = chart(nodeData);


			// this.resizers = [];
			// for(var i=0; i&lt;nodes.length; i++) {
			// this.resizers.push(Ext.create('Ext.resizer.Resizer',{target:nodes[i]}));
			// }
		}
	},
	addComplexes: function(records, index, nodes) {

		var me = this,
			data = [],
			segmentMap = me.getSegmentMap();

		for(var i = 0; i &lt; records.length; i++) {
			var rec = records[i];

			data.push({
				strands: _.map(rec.getStrands(), function(strandName) {
					return {
						name: strandName,
						domains: me.strandStore.findRecord('name', strandName).getParsedSpec()
					}
				}),
				structure: rec.get('structure'),
				sequences: segmentMap,
			});
		}

		if(nodes.length &gt; 0) {
			// Configure chart prototype
			var chart = me.getChart();

			// Build selection and chart
			var nodeData = d3.selectAll(nodes).data(data).append('svg');
			this.preview = chart(nodeData);


			// this.resizers = [];
			// for(var i=0; i&lt;nodes.length; i++) {
			// this.resizers.push(Ext.create('Ext.resizer.Resizer',{target:nodes[i]}));
			// }
		}
	},
	updateComplex: function(record, index, node) {
		var me = this,
			rec = record,
			segmentMap = this.getSegmentMap(),
			data = [{
				strands: _.map(rec.getStrands(), function(strandName) {
					return {
						name: strandName,
						domains: me.strandStore.findRecord('name', strandName).getParsedSpec()
					}
				}),
				structure: rec.get('structure'),
				sequences: segmentMap,
			}];
		var chart = me.getChart();

		var nodeData = d3.select(node).data(data).append('svg');
		chart(nodeData);
		this.preview.expandSelection(nodeData);

	},
	removeComplex: function(record, index) {

	},
	getSegmentMap: function() {
		if(this.segmentMap) {
			return this.segmentMap;
		} else if(this.segmentStore) {
			return this.segmentStore.getSegmentMap();
		}
	},
	getSegmentColorScale: function() {
		return this.segmentStore.getSegmentColorScale()
	},
	highlight: function(criteria) {
		this.preview.highlight(criteria);
	},
	unhighlight: function(criteria) {
		this.preview.unhighlight(criteria);
	},
	getMarkup: function(cb) {
		if(!this.svgStyles) {
			Ext.Ajax.request({
			    url: 'styles/strand-preview.css',
			    success: function(response){
			        this.svgStyles = response.responseText;
			        this.doGetMarkup(cb);
			    },
			    scope: this,
			});
		} else {
			this.doGetMarkup(cb);
		}
	},
	doGetMarkup: function(cb) {
		var me = this, 
			rowLength = 6,
			x_offset = 10,
			y_offset = 10,
			markup = _.map(this.getNodes(),function(node,index) {
				var x = index % rowLength, y = Math.floor(index / rowLength),
					markup = node.innerHTML.replace(/&lt;span(\b[^&gt;]*)&gt;([^&lt;]*)&lt;\/span&gt;/g,'&lt;text class=&quot;complex-label&quot;&gt;$2&lt;/text&gt;')
						.replace(/&lt;svg(\b[^&gt;]*)&gt;/g,'').replace('&lt;/svg&gt;','');
				return '&lt;g transform=&quot;translate('+[x_offset+x*me.cellWidth,y_offset+y*me.cellHeight]+')&quot;&gt;'+markup+'&lt;/g&gt;';
			}).join('\n');

		var value = '&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;'+
		'&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;&gt;'+
		'&lt;style type=&quot;text/css&quot;&gt;&lt;![CDATA[' + this.svgStyles + ']]&gt;&lt;/style&gt;'+
		markup+'&lt;/svg&gt;';

		cb(value);
	},
})

Ext.define('App.ui.EditComplexWindow', {
	extend: 'Ext.window.Window',
	closable: true,
	closeAction: 'hide',
	maximizable: true,
	width: 500,
	height: 300,
	renderTo: Ext.getBody(),
	autoRender: false,
	layout: 'fit',
	border: false,
	bodyBorder: false,

	initComponent: function() {
		Ext.apply(this,{
			items: [Ext.create('App.ui.EditComplexPanel',{
				complex: this.complex,
				strandManager: this.strandManager,
				segmentColors: this.segmentColors,
			})]
		});
		this.callParent(arguments);
	},

});

Ext.define('App.ui.EditComplexPanel', {
	extend: 'Ext.panel.Panel',
	alias: 'widget.editcomplexpanel',
	layout: 'border',
	border: false,
	bodyBorder: false,
	initComponent: function() {
		Ext.apply(this, {
			items: [{
				xtype: 'strandpreview',
				name: 'strandPreview',
				region: 'west',
				width: 300,
				height: 300,
				split: true,
			}, {
				xtype: 'form',
				name: 'formPanel',
				region: 'center',
				frame: true,
				defaults: {
					labelAlign: 'top',
					anchor: '100%',
				},
				items: [
				{
					//fieldLabel: 'Strands',
					xtype: 'textarea',
					name: 'strandsField',
					validator: Ext.bind(this.validateStrands, this),
					// floating: true,
					// autoRender: true,
				},
				 {
					fieldLabel: 'Strands',
					xtype: 'displayfield',
					name: 'segmentsField',
					cls: 'strand-glyph-well',
				}, {
					fieldLabel: 'Structure',
					xtype: 'textarea',
					name: 'structureField',
					validator: Ext.bind(this.validateStructure, this),
				}]
			}],
		});

		this.callParent(arguments);

		this.formPanel = this.down('[name=formPanel]');
		this.strandPreview = this.down('[name=strandPreview]');


		this.segmentsField = this.down('[name=segmentsField]');
		this.structureField = this.down('[name=structureField]');

		this.strandsField = this.down('[name=strandsField]');
		this.strandsField.on('blur',function() {
			this.updateSegmentsView();
		},this);
		// this.strandsField = Ext.create('Ext.form.field.TextArea',{
		// 	validator: Ext.bind(this.validateStrands, this),
		// });
		this.strandsFieldEditor = Ext.create('Ext.Editor',{
			field: this.strandsField ,
			hideEl: false,
			autoSize: {
				width:'boundEl',
				height:'boundEl',
			},
			alignment: 'tl-tl?',
		});
		this.on('afterrender',function () {
			this.segmentsField.getEl().on('click',function() {
				this.strandsFieldEditor.startEdit(this.segmentsField.inputEl,this.complex.getStrands().join('+'));
			},this);
		});

		this.on('afterrender', this.loadData, this);
		this.on('show',this.loadData,this);
		
		this.formPanel.on('validitychange',function(panel,valid) {
			if(valid) this.updateComplex();
		},this,{buffer: 100});
	},

<span id='global-method-loadData'>	/**
</span>	 * Loads #complexData for the record in #complex from the corresponding #strandManager
	 */
	loadData: function() {
		this.complexData = this.strandManager.getComplexData(this.complex);

		this.strandsField.setValue(this.complex.getStrands().join('+'));
		this.structureField.setValue(this.complexData.structure);
		this.updateView();
	},

<span id='global-method-updateComplex'>	/**
</span>	 * Updates the record stored in #complex with the data from #getStrands and #getStructure.
	 * Updates the #complexData and {@link #updateView updates the view}.
	 */
	updateComplex: function() {
		this.complex.beginEdit();
		this.complex.set('strands',this.getStrands());
		this.complex.set('structure',this.getStructure());
		this.complex.endEdit();
		this.complexData = this.getComplexData(this.complex);
		this.updateView();
	},

	updateView: function() {
		var me = this;
		if(!!this.segmentColors) this.strandPreview.segmentColors = this.segmentColors;
		this.strandPreview.setValue(this.complexData);
		this.segmentsField.setValue(_.map(this.complexData.strands, function(strand) {
			return me.buildStrandGlyph(strand);
		}).join(' + ') || '(click to edit)');	
	},
	updateSegmentsView: function() {
		var me = this,
			strands = this.getStrands();

		if(strands.length &gt; 0) {
			this.segmentsField.setValue(_.map(strands,function(name) {
				var strand = me.getStrandData(name);
				return me.buildStrandGlyph(strand,name);
			}).join(' + '));
		} else {
			this.segmentsField.setValue('(click to edit)');
		}
	},
	buildStrandGlyph: function(strand,name) {
		var out = '&lt;div class=&quot;strand-glyph'+(strand?'':' strand-glyph-unknown')+'&quot;&gt;';

		if(strand) { 
			out += '&lt;span class=&quot;strand-glyph-name&quot;&gt;'+strand.name+'&lt;/span&gt;'+ _.map(strand.segments, function(seg) {
				return DNA.makeIdentifier(seg.identity, seg.polarity);
			}).join(' ');
		} else {
			out += '&lt;span class=&quot;strand-glyph-name&quot;&gt;'+name+'&lt;/span&gt;'+' ? '
		}

		out+='&lt;/div&gt;';
		return out;
	},
	
	getStrands: function() {
		var strands = this.strandsField.getValue() || '';
		return  _.map(strands.split('+'), function(s) {
			return s.trim();
		});
	},
	getStructure: function() {
		return this.structureField.getValue() || '';
	},
	getStrandData: function() {
		return this.strandManager.getStrandData.apply(this.strandManager, arguments);
	},
	getComplexData: function() {
		return this.strandManager.getComplexData.apply(this.strandManager, arguments);
	},
	validateStrands: function() {
		var strands = this.getStrands();

		for(var i = 0; i &lt; strands.length; i++) {
			var strand = this.getStrandData(strands[i]);
			if(!strand) {
				return &quot;Unknown strand '&quot; + strands[i] + &quot;'&quot;;
			}
		}
		this.structureField.validate();
		return true;
	},
	validateStructure: function() {
		var strands = this.getStrands(),
			structure = this.getStructure();
		
		// ensure input structure is valid dot-paren
		var err = DNA.validateDotParen(structure,/* report errors as strings */ true, /* prohibit unrecognized chars */ true);
		if(err !== true) {
			return err;	
		}

		// split into strand-wise structure
		structures = structure.split('+');

		// test overall length equality
		if(strands.length != structures.length) {
			return Ext.String.format(&quot;Strand count and structure count do not match; {0} strands and {1} structures. &quot;+
				&quot;Make sure to separate structures for different strands with + signs.&quot;, strands.length, structures.length);
		} else {

			// test segment-wise length dimensioning
			for(var i = 0; i &lt; strands.length; i++) {

				// should not be encountered, but in case unrecognized strand is encountered
				var strand = this.getStrandData(strands[i]);
				if(!strand) {
					return &quot;Please correct strand field to remove unrecognized strand.&quot;;
				}

				if(strand.segments.length != structures[i].length) {
					return Ext.String.format(&quot;Strand length mismatch; strand '{0}' has {1} segments, but its structure has {2} elements.&quot;, strands[i], strand.segments.length, structures[i].length);
				}
			}
			return true;
		}
	},
})

<span id='App-ui-StrandsGrid'>/**
</span> * @class 
 */
Ext.define('App.ui.StrandsGrid',{
	extend: 'Ext.grid.Panel',
	alias: 'widget.strandsgrid',
<span id='App-ui-StrandsGrid-cfg-store'>	/**
</span>	 * @cfg {App.ui.StrandStore} store (required)
	 * Store containing Strand records
	 */	
<span id='App-ui-StrandsGrid-cfg-segmentStore'>	/**
</span>	 * @cfg {App.ui.SegmentStore} segmentStore (required)
	 * Store containing Segment records
	 */
	initComponent: function () {

		this.strandEditor = Ext.create('Ext.grid.plugin.CellEditing', {
			clicksToEdit: 1
		});
		this.strandStore = this.store;

		Ext.apply(this,{
			tbar: [{
				text: 'Add',
				iconCls: 'plus',
				handler: this.doAddStrand,
				scope: this,
			},{
				text: 'Edit',
				iconCls: 'pencil',
				handler: this.doEditStrand,
				scope: this,
			},{
				text: 'Delete',
				iconCls: 'delete',
				handler: this.doDeleteStrand,
				scope: this,
			}],

			columns: [{
				text: 'Name',
				dataIndex: 'name',
				allowBlank: false,
				width: 90,
			}, {
				text: 'Sequence',
				dataIndex: 'sequence',
				allowBlank: false,
				renderer: function(value, metaData, record, rowIndex, colIndex, store, view) {
					var spec = record.getParsedSpec(),
						pos = 0,
						// base-wise index within strand, updated as we iterate below
						segmentMap = record.store.getSegmentMapWithComplements(),
						out = [],
						renderer = CodeMirror.getModeRenderer('sequence', {
							renderer: function(text, style, col) {
								var index = pos + col - 1;
								if(style) return &quot;&lt;span class='sequence-base cm-&quot; + style + &quot;' data-base-index='&quot; + index + &quot;'&gt;&quot; + text + &quot;&lt;/span&gt;&quot;
								else return &quot;&lt;span class='sequence-base' data-base-index='&quot; + index + &quot;'&gt;&quot; + text + &quot;&lt;/span&gt;&quot;

							}
						});

					for(var i = 0; i &lt; spec.length; i++) {
						var dom = spec[i];
						for(var j = 0; j &lt; dom.segments.length; j++) {
							var seg = dom.segments[j],
								seq = segmentMap[DNA.makeIdentifier(seg.identity, seg.polarity)];
							out.push('&lt;span class=&quot;sequence-segment&quot; data-segment-identity=&quot;' + seg.identity + '&quot; data-segment-polarity=&quot;' + seg.polarity + '&quot;&gt;' + renderer(seq) + '&lt;/span&gt;');
							pos += seq.length;
						}
					}
					return out.join('');
				},
				scope: this,
				flex: 1,
			}, {
				text: 'Segments',
				dataIndex: 'spec',
				field: {
					xtype: 'textfield',
					validator: Ext.bind(function(value) {
						var segmentMap = this.getSegmentMap();
						var doms = App.dynamic.Compiler.parseDomainString(value,/*parseIdentifier*/ true);
						for(var i=0; i&lt;doms.length; i++) {
							var segs = doms[i].segments;
							for(var j=0; j&lt;segs.length; j++) {
								var seg = segs[j];
								if(!segmentMap[seg.identity]) {
									return &quot;Unknown segment: '&quot;+seg.identity+&quot;'&quot;;
								}
							}
						}
						return true;
					},this),
					listeners: {
						// 'focus': {
						// 	fn: function onFocus (cmp,e) {
						// 		cmp.origVal = cmp.getValue();
						// 	},
						// 	scope: this,
						// }
						// 'blur':  {
						// 	fn: function onBlur (cmp,e) {
						// 		var value = cmp.getValue();
						// 		if(value != cmp.origVal &amp;&amp; cmp.isValid()) {

						// 		}
						// 		delete cmp.origVal;
						// 	},
						// 	scope: this,
						// }
					}
				},
				renderer: function(str) {
					var spec = App.dynamic.Compiler.parseDomainString(str);
					return _.map(spec,function(dom) {
						return '&lt;div class=&quot;domain-glyph domain-glyph-'+dom.role+'&quot;&gt;&lt;span class=&quot;domain-glyph-name&quot;&gt;'+dom.name+'&lt;/span&gt;'+
							_.map(dom.segments,function(seg) { return '&lt;span class=&quot;segment-glyph segment-glyph-'+seg.role+'&quot;&gt;'+seg.name+'&lt;/span&gt;' }).join(' ')+'&lt;/div&gt;'
					}).join(' ');
				}, // CodeMirror.modeRenderer('dil-domains', 'cm-s-default'),
				flex: 1,
			}, {
				text: 'Complex',
				dataIndex: 'complex'
			}, ],
			plugins: [this.strandEditor],
		});

		this.callParent(arguments);
	},
	getSegmentMap: function () {
		return this.segmentStore.getSegmentMapWithComplements()
	},
	highlightSegment: function(identity, polarity) {
		if(polarity === undefined) polarity = 1;
		var el = this.getEl();
		el.select('[data-segment-identity=&quot;' + identity + '&quot;][data-segment-polarity=&quot;' + polarity + '&quot;]').addCls('sequence-highlight');
		el.select('[data-segment-identity=&quot;' + identity + '&quot;][data-segment-polarity=&quot;' + (-1 * polarity) + '&quot;]').addCls('sequence-highlight-complement');
	},
	unhighlightSegment: function() {
		var el = this.getEl();
		el.select('.sequence-highlight').removeCls('sequence-highlight');
		el.select('.sequence-highlight-complement').removeCls('sequence-highlight-complement');
	},
	addStrand: function() {
		return _.first(this.strandStore.addStrand());
	},
	doAddStrand: function() {
		var rec = this.addStrand();
		this.editStrand(rec);
	},
	editStrand: function editStrand (rec) {
		rec || (rec = this.strandsGrid.getSelectionModel().getLastSelected());
		if (rec) {
			this.strandEditor.startEdit(rec, this.strandsGrid.headerCt.getHeaderAtIndex(2));
		}
	},
	doEditStrand: function() {
		return this.editStrand();
	},
	deleteStrand: function deleteStrand (rec) {
		// body...
	},
	doDeleteStrand: function() {
		return this.deleteStrand();
	},
});

Ext.define('App.ui.SegmentsGrid',{
	extend: 'Ext.grid.Panel',
	alias: 'widget.segmentsgrid',
	initComponent: function (argument) {
		this.segmentEditor = Ext.create('Ext.grid.plugin.CellEditing', {
			clicksToEdit: 1
		});

		this.segmentStore = this.store;

		Ext.apply(this,{
			tbar: [Ext.create('App.ui.AddDomainButton', {
				addDomain: Ext.bind(this.createSegment, this),
				extraMenuItems: [{
					text: 'Add many segments...',
					handler: this.showAddSegmentsWindow,
					scope: this,
				}]
			}),{
				text: 'Edit',
				iconCls: 'pencil',
				handler: this.editSegment,
				scope: this,
			},{
				text: 'Delete',
				iconCls: 'delete',
				handler: this.deleteSegment,
				scope: this,
			}],

			columns: [{
				dataIndex: 'color',
				field: {
					xtype: 'colorfield',
					pickerOptions: {
						colors: [
							&quot;1F77B4&quot;, &quot;AEC7E8&quot;, &quot;FF7F0E&quot;, &quot;FFBB78&quot;, &quot;2CA02C&quot;, &quot;98DF8A&quot;, &quot;D62728&quot;, &quot;FF9896&quot;, &quot;9467BD&quot;, &quot;C5B0D5&quot;, &quot;8C564B&quot;, &quot;C49C94&quot;, &quot;E377C2&quot;, &quot;F7B6D2&quot;, &quot;7F7F7F&quot;, &quot;C7C7C7&quot;, &quot;BCBD22&quot;, &quot;DBDB8D&quot;, &quot;17BECF&quot;, &quot;9EDAE5&quot;,
							&quot;3182BD&quot;, &quot;6BAED6&quot;, &quot;9ECAE1&quot;, &quot;C6DBEF&quot;, &quot;E6550D&quot;, &quot;FD8D3C&quot;, &quot;FDAE6B&quot;, &quot;FDD0A2&quot;, &quot;31A354&quot;, &quot;74C476&quot;, &quot;A1D99B&quot;, &quot;C7E9C0&quot;, &quot;756BB1&quot;, &quot;9E9AC8&quot;, &quot;BCBDDC&quot;, &quot;DADAEB&quot;, &quot;636363&quot;, &quot;969696&quot;, &quot;BDBDBD&quot;, &quot;D9D9D9&quot;,
							&quot;393B79&quot;, &quot;5254A3&quot;, &quot;6B6ECF&quot;, &quot;9C9EDE&quot;, &quot;637939&quot;, &quot;8CA252&quot;, &quot;B5CF6B&quot;, &quot;CEDB9C&quot;, &quot;8C6D31&quot;, &quot;BD9E39&quot;, &quot;E7BA52&quot;, &quot;E7CB94&quot;, &quot;843C39&quot;, &quot;AD494A&quot;, &quot;D6616B&quot;, &quot;E7969C&quot;, &quot;7B4173&quot;, &quot;A55194&quot;, &quot;CE6DBD&quot;, &quot;DE9ED6&quot;,
						]
					}
				},
				renderer: function(color) {
					return '&lt;div style=&quot;width:12px;height:12px;background-color:'+color+';&quot;&gt;&amp;nbsp;&lt;/div&gt;'
				},
				width: 40,
			},{
				text: 'Name',
				dataIndex: 'identity',
				flex: 1,
			}, {
				text: 'Sequence',
				dataIndex: 'sequence',
				field: 'textfield',
				renderer: CodeMirror.modeRenderer('sequence'),
				flex: 5,
			}, {
				text: 'Length',
				dataIndex: 'sequence',
				renderer: function(seq) {
					return seq.length;
				},
				flex: 1,
			}],
			plugins: [this.segmentEditor],
		});

		this.callParent(arguments);
	},

	showAddSegmentsWindow: function() {
		var me = this;
		if(!this.addSegmentsWindow) {
			this.addSegmentsWindow = Ext.create('App.ui.SequenceWindow',{
				handler: function(domains) {
					me.updateSegments(domains);
				},
				title: 'Add segments to system'
			});
		}
		this.addSegmentsWindow.show();
	},
	
	addSegment: function(identity,sequence) {
		return _.first(this.segmentStore.add({
			identity: identity,
			sequence: sequence,
			color: this.segmentStore.getColor(identity),
		}));
	},
	addSegments: function(map) {
		var me = this;
		return this.segmentStore.add(_.map(map,function(sequence,identity) {
			return {
				identity: identity,
				sequence: sequence,
				color: me.segmentStore.getColor(identity),
			}
		}));
	},
	updateSegments: function(map) {
		var me = this;
		return _.map(map,function(sequence,identity) {
			var seg = me.segmentStore.findRecord('identity',identity);
			if(seg) {
				seg.set('sequence',sequence);
				return seg;
			} else {
				return _.first(me.segmentStore.add({
					identity: identity,
					sequence: sequence,
					color: me.segmentStore.getColor(identity),
				}));
			}
		});
	},
	createSegment: function(length) {
		return _.first(this.segmentStore.addSegment(length));
	},
	editSegment: function editSegment (rec) {
		rec || (rec = this.segmentsGrid.getSelectionModel().getLastSelected());
		if (rec) {
			//this.segmentEditor.startEdit(rec, this.segmentsGrid.headerCt.getHeaderAtIndex(2));
			this.segmentEditor.startEdit(rec, this.headerCt.getHeaderAtIndex(2));
		}
	},
	doEditSegment: function() {
		return this.editSegment();
	},
	deleteSegment: function (rec) {
		// body...
	},
	doDeleteSegment: function() {
		return this.deleteSegment();
	},

})

Ext.define('App.ui.StrandEdit', {
	extend: 'Ext.panel.Panel',
	layout: 'border',
	border: false,
	bodyBorder: false,
	alias: 'widget.strandedit',
	mixins: {
		app: 'App.ui.Application',
		tip: 'App.ui.TipHelper',
	},
	requires: ['App.ui.D3Panel', 'App.ui.SequenceEditor', 'App.ui.dd.RulesWindow', 'App.ui.dd.ScoreParametersWindow', //
	'App.ui.dd.SequenceWindow', 'App.ui.SequenceThreader', 'App.ui.AddDomainButton', 'App.ui.StrandPreviewViewMenu'],
	constructor: function() {
		this.mixins.app.constructor.apply(this, arguments);
		this.editComplexWindows = {};

		this.callParent(arguments);
	},
	title: 'Strand Editor',
	iconCls: 'domains',
	editorType: 'System',
	initComponent: function() {
		this.segmentStore = Ext.create('App.ui.SegmentStore', {});
		this.strandStore = Ext.create('App.ui.StrandStore', {
			segmentStore: this.segmentStore
		});
		this.complexStore = Ext.create('App.ui.ComplexStore', {
			strandStore: this.strandStore
		});
		

		Ext.apply(this, {
			tbar: [{
				xtype: 'buttongroup',
				columns: 2,
				title: 'Design Sequences',
				items: [{
					text: 'DD',
					width: 64,
					iconCls: 'sequence-24',
					scale: 'medium',
					iconAlign: 'top',
					rowspan: 2,
					handler: this.buildDD,
					scope: this,
				}, {
					text: 'NUPACK',
					iconCls: 'nupack-icon',
					handler: this.buildNupack,
					scope: this,
				}, {
					text: 'Multisubjective',
					iconCls: 'ms-icon',
					handler: this.buildMS,
					scope: this,
					disabled: true,
				}]
			}, {
				xtype: 'buttongroup',
				columns: 2,
				title: 'Kinetics',
				items: [{
					text: 'Enumerate',
					scale: 'medium',
					rowspan: 2,
					iconAlign: 'top',
					iconCls: 'enumerate-24',
					handler: this.buildEnum,
					scope: this,
				}, {
					text: 'to PIL',
					iconCls: 'pil',
				}, {
					text: 'to Graph (ENJS)'
				}],
				//disabled: true,
			}, {
				xtype: 'buttongroup',
				columns: 2,
				title: 'Thermodynamics',
				items: [{
					text: 'Predict structures',
					scale: 'medium',
					rowspan: 2,
					iconAlign: 'top',
					iconCls: 'secondary-24',
					handler: this.buildTherm,
					scope: this,
				}, {
					text: 'Complexes',
				}, {
					text: 'MFE structure'
				}],
				//disabled: true,
			}, {
				xtype: 'buttongroup',
				columns: 2,
				title: 'Export',
				items: [{
					text: 'SVG',
					iconCls: 'svg',
					scale: 'medium',
					iconAlign: 'top',
					rowspan: 2,
					handler: this.displaySVGWindow,
					scope: this,
				}, {
					text: 'PIL',
					iconCls: 'pil',
					handler: this.buildPil,
					scope: this,
				}, {
					text: 'DyNAML',
					iconCls: 'dynaml',
					disabled: true,
				}]
			}, '-&gt;',
			{
				xtype: 'buttongroup',
				columns: 1,
				title: 'Workspace',
				items: [Ext.create('App.ui.SaveButton', {
					app: this
				}),
				{
					text: 'Help',
					iconCls: 'help',
					handler: App.ui.Launcher.makeLauncher('help:dil'),
				}]
			}],
			items: [{
				xtype: 'strandsgrid',
				name: 'strandsGrid',
				store: this.strandStore,
				segmentStore: this.segmentStore,
				region: 'south',
				collapsible: true,
				titleCollapse: true,
				title: 'Strands',
				height: 200,
				split: true,
			}, {
				xtype: 'segmentsgrid',
				name: 'segmentsGrid',
				store: this.segmentStore,
				title: 'Segments',
				titleCollapse: true,
				collapsible: true,
				region: 'east',
				width: 200,
				split: true,
			}, {
				xtype: 'panel',
				layout: 'fit',
				region: 'center',
				items: [Ext.create('App.ui.StrandPreviewGrid', {
					name: 'complexView',
					store: this.complexStore,
					strandStore: this.strandStore,
					segmentStore: this.segmentStore,
					listeners: {
						'itemdblclick': {
							fn: function(view, complex, node) {
								this.showEditComplexWindow(complex, node);
							},
							scope: this,
						}
					}
				})],
				bbar: [{
					text: 'Add',
					iconCls: 'plus',
					handler: this.doAddComplex,
					scope: this,
				},{
					text: 'Edit',
					iconCls: 'pencil',
					handler: this.doEditComplex,
					scope: this,
				},{
					text: 'Delete',
					iconCls: 'delete',
					handler: this.doDeleteComplex,
					scope: this,
					disabled: true,
				},'-&gt;',
				Ext.create('App.ui.StrandPreviewViewMenu',{view:null,name:'complexViewMenu'})],
			}]
		});
		this.on('afterrender', this.loadFile, this);
		this.callParent(arguments);
		this.strandsGrid = this.down('[name=strandsGrid]');
		this.segmentsGrid = this.down('[name=segmentsGrid]');
		this.complexView = this.down('[name=complexView]');

		this.down('[name=complexViewMenu]').view = this.complexView;

		this.segmentStore.on('update', function(store, rec, operation, modifiedFieldNames) {
			this.updateStrandSequences();
		}, this);

		this.segmentsGrid.on('itemmouseenter', function(grid, rec, el, e) {
			this.fireEvent('updateSegmentHighlight', rec.get('identity'), 1);
		}, this);
		this.segmentsGrid.on('itemmouseleave', function(grid, rec, el, e) {
			this.fireEvent('updateSegmentHighlight', null);
		}, this);


		this.on('updateSegmentHighlight', this.updateSegmentHighlight, this, {
			buffer: 10,
		});

		this.on('afterrender', function() {
			this.strandsGrid.getEl().on('mouseover', function(e, el) {
				var identity = el.getAttribute('data-segment-identity'),
					polarity = el.getAttribute('data-segment-polarity');
				this.fireEvent('updateSegmentHighlight', identity, polarity);
			}, this, {
				delegate: 'span.sequence-segment'
			});

			// this.strandsGrid.getEl().on('mouseover', function(e, el) {
			// 	el.addCls('sequence-base-hover');
			// }, this, {
			// 	delegate: 'span.sequence-base'
			// });
			// this.strandsGrid.getEl().on('mouseout', function(e, el) {
			// 	el.removeCls('sequence-base-hover');
			// }, this, {
			// 	delegate: 'span.sequence-base'
			// });

			this.tip = Ext.create('Ext.tip.ToolTip', {
				target: this.strandsGrid.getEl(),
				delegate: 'span.sequence-base',
				trackMouse: true,
				showDelay: false,
				renderTo: Ext.getBody(),
				listeners: {
					// Change content dynamically depending on which element triggered the show.
					beforeshow: {
						fn: function updateTipBody(tip) {
							var segmentElement = Ext.get(tip.triggerElement).up('span.sequence-segment'),
								identity = segmentElement.getAttribute('data-segment-identity'),
								polarity = segmentElement.getAttribute('data-segment-polarity'),
								index = tip.triggerElement.getAttribute('data-base-index')+1;
							//tip.setTitle(DNA.makeIdentifier(identity, polarity));
							//tip.update(index + ' nt');
							tip.update('Segment: &lt;b&gt;'+DNA.makeIdentifier(identity, polarity) + '&lt;/b&gt; / Base: ' + index);
							//this.fireEvent('updateSegmentHighlight',identity);
						},
						scope: this
					}
				}
			});
		}, this);

		// this.segmentsGrid.on('containermouseout',function(grid,rec,el,e) {
		// 	this.unhighlightSegment();
		// },this);
	},
	onLoad: function() {
		if(!_.isObject(this.data) &amp;&amp; _.isString(this.data) &amp;&amp; !! this.data) {
			try {
				this.data = JSON.parse(this.data)
			} catch(e) {
				Ext.msg(&quot;Unable to load strand data.&quot;);
				console.error(e);
			}
		} else {
			this.data = {};
		}

		this.library = App.dynamic.Library.fromDil(this.data);
		this.loadLibrary(this.library);
		_.defer(_.bind(this.complexView.refresh, this.complexView));
	},

	/* ------------------------------------------------------------------------------------------- 
	   Complex management                                                                        */


	addComplex: function() {
		return _.first(this.complexStore.addComplex());
	},
	doAddComplex: function() {
		var rec = this.addComplex();
		this.editComplex(rec);
	},
	editComplex: function editComplex (rec) {
		rec || (rec = this.complexView.getSelectionModel().getLastSelected());
		if (rec) {
			this.showEditComplexWindow(rec);
		}
	},
	doEditComplex: function() {
		this.editComplex();
	},
	
	/* ------------------------------------------------------------------------------------------- 
	   Data handling                                                                             */

<span id='App-ui-StrandsGrid-method-getComplexData'>	/**
</span>	 * Gets the names of strands, the structure, and the sequences for segments comprising a complex.
	 * @param  {String/Complex} rec A record or name representing the complex in question
	 * @return {Object} An object containing the complexData
	 * @return {Object[]} return.strands (see #getStrandData)
	 * @return {String} return.structure
	 * @return {Object} return.sequences (see #getSegmentMap)
	 */
	getComplexData: function(rec) {
		if(_.isString(rec)) {
			rec = this.complexStore.findRecord('name', rec);
		}
		if(rec) {
			return {
				strands: _.map(rec.getStrands(), this.getStrandData, this),
				structure: rec.get('structure'),
				sequences: this.getSegmentMap(),
			}
		}
	},
<span id='App-ui-StrandsGrid-method-getStrandData'>	/**
</span>	 * Gets the name, the list of domains, and the list of segments in a strand
	 * @param  {String/Strand} rec A record or name representing the strand in question
	 * @return {Object} An object containing the strandData
	 * @return {String} return.name
	 * @return {Object[]} return.domains
	 * @return {Object[]} return.segments
	 */
	getStrandData: function(rec) {
		if(_.isString(rec)) {
			rec = this.strandStore.findRecord('name', rec);
		}
		if(rec) {
			return {
				name: rec.get('name'),
				domains: _.clone(rec.getParsedSpec()),
				segments: _.clone(rec.getFlatSpec()),
			}
		}
	},

	getSegmentMap: function() {
		return this.segmentStore.getSegmentMap()
	},
	updateStrandSequences: function() {
		var segmentMap = this.getSegmentMap();
		this.strandStore.each(function(strand) {
			var strandSpec = strand.getFlatSpec();
			strand.set('sequence', DNA.threadSegments(segmentMap, strandSpec));
		}, this);
	},
	getSegmentColorScale: function() {
		return this.complexView.getSegmentColorScale();
	},
	showEditComplexWindow: function(complex, node) {
		var name = complex.get('name');
		node || (this.complexView.getNode(complex));
		if(!this.editComplexWindows[name]) {
			this.editComplexWindows[name] = Ext.create('App.ui.EditComplexWindow', {
				complex: complex,
				renderTo: Ext.getBody(),
				title: name,
				strandEditor: this,
				segmentColors: this.getSegmentColorScale(),
			});
		}
		this.editComplexWindows[name].show();
		if(node) {
			this.editComplexWindows[name].alignTo(node, 'tl-tl');
		}
	},

	/* ------------------------------------------------------------------------------------------- 
	   Visualization                                                                             */

	updateSegmentHighlight: function(identity, polarity) {
		if(identity) {
			this.highlightSegment(identity, polarity);
		} else {
			this.unhighlightSegment();
		}
	},
	highlightSegment: function(segment, polarity) {
		this.complexView.preview.fade();
		this.complexView.preview.highlight({
			'segment_identity': segment,
			'segment_polarity': polarity
		}, 'node-highlight');
		this.complexView.preview.highlight({
			'segment_identity': segment,
			'segment_polarity': -1 * polarity
		}, 'node-highlight-complement');

		this.strandsGrid.unhighlightSegment();
		this.strandsGrid.highlightSegment(segment, polarity);
	},
	unhighlightSegment: function(segment, polarity) {
		this.complexView.preview.unfade();
		this.complexView.preview.unhighlight(null, 'node-highlight');
		this.complexView.preview.unhighlight(null, 'node-highlight-complement');

		this.strandsGrid.unhighlightSegment();
	},

	/* ------------------------------------------------------------------------------------------- 
	   Builds                                                                                    */

	buildTarget: function(target) {

		this.requestDocument(function(doc) {
			var data = this.serializeDil(),
				node = this.getDocumentPath(),
				outNode, action, ext;

			switch(target) {
			case 'dd':
				action = 'dd', ext = 'domains', target = 'DD';
				break;
			case 'nupack':
				action = 'nupack', ext = 'np', target = 'NUPACK';
				break;
			case 'ms':
				action = 'ms', ext = 'ms', target = 'Multisubjective';
				break;
			case 'pil':
				action = 'pil', ext = 'pil', target = 'PIL';
				break;
			case 'enum':
				action = 'enum', ext = 'enum', 'Enumerator';
				break;
			case 'svg':
				action = 'svg', ext = 'svg', 'SVG';
				break;
			}
			outNode = App.path.repostfix(node, ext);

			App.runTask('Nodal', {
				node: node,
				data: data,
				action: action,
			}, function(responseText, args, success) {
				if(success) App.msg('DIL Output', 'Output of system &lt;strong&gt;{0}&lt;/strong&gt; to {1} completed.', doc.getBasename(), target);
				else App.msg('DIL Output error', 'Output of system &lt;strong&gt;{0}&lt;/strong&gt; to {1} failed! See Console for details.', {
					params: [doc.getBasename(), target],
					handler: 'console'
				})
			}, this, {
				openOnEnd: [outNode],
			});

		}, this);
	},

	buildDD: function() {
		this.buildTarget('dd')
	},
	buildNupack: function() {
		this.buildTarget('nupack')
	},
	buildMS: function() {
		this.buildTarget('ms')
	},
	buildPil: function() {
		this.buildTarget('pil')
	},
	buildSVG: function() {
		this.buildTarget('svg')
	},
	buildEnum: function() {
		this.buildTarget('enum')
	},
	displaySVGWindow: function() {
		this.complexView.getMarkup(Ext.bind(this.doDisplaySVGWindow,this));
	},
	doDisplaySVGWindow: function (value) {
		this.svgWindow = Ext.create('App.ui.StrandPreviewTextWindow',{
			title: 'SVG',
		});
		this.svgWindow.show();
		this.svgWindow.setValue(value);
	},
	

	loadLibrary: function(library) {
		library || (library = {});
		var complexStore = this.complexStore,
			strandStore = this.strandStore,
			segmentStore = this.segmentStore,
			segmentColors = d3.scale.category20();

		segmentStore.colorGenerator = segmentColors;
		segmentStore.add(_.map(library.segments || [], function(seg) {
			return {
				identity: seg.getIdentity(),
				sequence: seg.getSequence(),
				color: !!seg.color ? seg.color : segmentColors(seg.getIdentity()),
			};
		}));

		complexStore.add(_.map(library.nodes || [], function(node) {

			strandStore.add(_.map(node.getStrands() || [], function(strand) {
				return {
					name: strand.getQualifiedName(),
					sequence: strand.getSequence(),
					complex: strand.getNode().getName(),
					spec: strand.printDomains( /* omitLengths */ true),
					polarity: strand.getPolarity()
				};
			}));

			return {
				name: node.getName(),
				polarity: node.getPolarity(),
				structure: node.getSegmentwiseStructure().toDotParen(),
				strands: _.map(node.getStrands(), function(strand) {
					return strand.getQualifiedName()
				})
			};
		}));
	},
	buildLibrary: function() {
		var segmentIds = this.segmentStore.getRange(),
			strandRecs = this.strandStore.getRange(),
			complexRecs = this.complexStore.getRange(),
			segmentMap = {},
			allSegments = [],
			strandMap = {},
			strands = [],
			nodes = [];


		// Build map of segment identities to sequences
		for(var i = 0; i &lt; segmentIds.length; i++) {
			var rec = segmentIds[i],
				seg = {
					identity: rec.get('identity'),
					sequence: rec.get('sequence'),
					color: rec.get('color')
				};
			allSegments.push(seg);
			segmentMap[seg.identity] = seg.sequence;
		}

		// Build objects for strands
		for(var i = 0; i &lt; strandRecs.length; i++) {
			var rec = strandRecs[i],
				strand, doms = _.clone(rec.getParsedSpec());

			// Update domain objects (built from spec) with sequence info
			for(var j = 0; j &lt; doms.length; j++) {
				var dom = doms[j];
				for(var k = 0; k &lt; dom.segments.length; k++) {
					var seg = dom.segments[k];
					seg.sequence = segmentMap[seg.identity];
				}
			}

			strand = {
				name: rec.get('name'),
				domains: doms
			};
			strands.push(strand);
			strandMap[strand.name] = strand;
		}

		// Build objects for nodes
		for(var i = 0; i &lt; complexRecs.length; i++) {
			var complex = complexRecs[i],
				complexStrands = complex.getStrands(),
				node;

			node = {
				name: complex.get('name'),
				structure: complex.get('structure'),
				polarity: complex.get('polarity'),
				strands: _.map(complexStrands, function(strand) {
					return strandMap[strand]
				})
			};

			nodes.push(node);
		}

		// Build new library object
		return new App.dynamic.Library({
			nodes: nodes,
			allSegments: allSegments
		});
	},
	serializeDil: function() {
		var lib = this.buildLibrary();
		return lib.toDilOutput();
	},
	getSaveData: function() {
		return this.serializeDil();
	},
	
})</pre>
</body>
</html>
