<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">////////////////////////////////////////////////////////////////////////////////////////////////
<span id='Workspace-tools-secondary-StrandTool'>/**
</span> * @class Workspace.tools.secondary.StrandTool
 * Draws multi-domain strands
 */
Ext.define('Workspace.tools.secondary.StrandTool', {
	constructor : function(workspace, config) {
		this.callParent(arguments);
		Ext.apply(this.parameters, {
			//&quot;arrow-end&quot; : 'classic-wide-long',
			&quot;stroke&quot; : &quot;#aaa&quot;,
			&quot;stroke-width&quot; : 2,
			&quot;stroke-dasharray&quot; : '',
		})
		this.bases = [];
	},
	extend : 'Workspace.tools.PolyLineTool',
	requires : ['Workspace.objects.secondary.Strand'],
	bulgeThreshold : 10,
	baseSpacing : 10,
	baseRadius : 3,
	buildObject : function() {
		return {
			wtype : 'Workspace.objects.secondary.Strand',
			points : this.currentPoints,
			//path: this.currentPath,
			fillOpacity : 0.1,
			baseSpacing : 10,
		};
	},
	getDistance : function(pos1, pos2) {
		function dist(p1, p2) {
			return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));
		};

		return dist([pos1.x, pos1.y], [pos2.x, pos2.y]);
	},
	snapDistance : function(distance) {
		return this.baseSpacing * this.countBases(distance);
	},
	countBases : function(distance) {
		return Math.floor(distance / this.baseSpacing);
	},
	nextPosition : function(lastPos, angle, distance) {
		return {
			x : lastPos.x + Math.cos(angle) * distance,
			y : lastPos.y + Math.sin(angle) * distance,
		};
	},
	snapXY : function(pos, lastPos) {

		if(lastPos) {
			var distance = this.getDistance(pos, lastPos), snapDistance = this.snapDistance(distance), angle = Math.atan2(pos.y - lastPos.y, pos.x - lastPos.x);
			//Raphael.rad(Raphael.angle(,pos.y,lastPos.x,lastPos.y));

			return this.nextPosition(lastPos, angle, snapDistance);
		}
		return pos;
	},
	makeBase : function() {
		var circle = this.workspace.paper.circle(0, 0, this.baseRadius);
		circle.attr({
			fill : this.parameters.stroke,
			stroke : this.parameters.stroke,
		});
		return circle;
	},
	moveBase : function(base, x, y, r) {
		base.attr({
			cx : x,
			cy : y,
			transform : 'R'+r
		});
	},
	addPoint : function(mouseupPos,mousedownPos) {
		var bulgeRadius = App.Geom.Point.fromMixed(mouseupPos).distance(mousedownPos);
		if(bulgeRadius &gt; this.bulgeThreshold) {
			var pos = mousedownPos;
			var nextPoint = [pos.x, pos.y, bulgeRadius];
		
		} else {
			var pos = mouseupPos;
			var nextPoint = [pos.x, pos.y];	
		}
		var nextCommand = this.getCommand(mouseupPos,mousedownPos,bulgeRadius);
		
		this.x = parseInt(pos.x);
		this.y = parseInt(pos.y);

		this.lastPos = {
			x : this.x,
			y : this.y
		};
		
		this.currentPoints.push(nextPoint);
		this.currentPath.push(nextCommand);
		this.points.push(nextPoint);

		console.log(this.points);
		
		this.currentShape.attr({
			path : this.currentPath
		});
		this.bases = this.bases.concat(this.segmentBases);
		this.segmentBases = [];
	},
	getCommand : function(mouseupPos,mousedownPos,bulgeRadius) {
		if(mousedownPos) {
			bulgeRadius || (bulgeRadius = App.Geom.Point.fromMixed(mouseupPos).distance(mousedownPos));
			if(bulgeRadius &gt; this.bulgeThreshold) {
				var p1 = App.Geom.Point.fromMixed(_.last(this.currentPoints)), //
					p2 = App.Geom.Point.fromMixed(mousedownPos);
				
				var mid = p1.midpoint(p2), //
					mid2 = mid.addPolar(p1.angle(p2) + Math.PI/2,-bulgeRadius);
					
				var cw = Math.abs(bulgeRadius), //
					c1 = mid2.addPolar(p1.angle(p2),-cw), //
					c2 = mid2.addPolar(p1.angle(p2),cw);
					
				//return ['C',c1.x, ',', c1.y, ' ', c2.x, ',', c2.y, ' ', p2.x, ',', p2.y, ];
				return ['C',c1.x, c1.y, c2.x, c2.y, p2.x, p2.y, ];

			}
		}
		return ['L', parseInt(mouseupPos.x), parseInt(mouseupPos.y)];
	},
	updateDrawing : function(pos,mousedownPos) {
		var nextCommand;
		if(this.dragging) {
			nextCommand = this.getCommand(pos,mousedownPos);
		} else {
			nextCommand = this.getCommand(pos);//['L', parseInt(pos.x), parseInt(pos.y)];
		}
		
		this.currentPath.pop();
		this.currentPath.push(nextCommand);
		this.currentShape.attr({
			path : this.currentPath
		});
		
		
		//this.callParent(arguments);
		var lastTwoCommands = _.last(this.currentPath,2);
		var segmentPath = [['M'].concat(_.last(lastTwoCommands[0],2)), nextCommand];
		var distance = Raphael.getTotalLength(segmentPath);//this.snapDistance(this.getDistance(pos, this.lastPos));
		var baseCount = this.countBases(distance), angle = Math.atan2(pos.y - this.lastPos.y, pos.x - this.lastPos.x);

		// make new bases if we need more
		if(baseCount &gt; this.segmentBases.length) {
			// for each new base
			for(var i = 0, l = baseCount - this.segmentBases.length; i &lt; l; i++) {
				this.segmentBases.push(this.makeBase());
			}

			// remove old bases if we've got too many
		} else if(baseCount &lt; this.segmentBases.length) {
			for(var i = 0, l = this.segmentBases.length - baseCount; i &lt; l; i++) {
				var base = this.segmentBases.pop();
				base.remove();
			}
		}

		//var point = this.nextPosition(this.lastPos, angle, this.baseSpacing / 2);
		var length = this.baseSpacing / 2, point;
		for(var i = 0; i &lt; baseCount; i++) {
			point = Raphael.getPointAtLength(segmentPath,length);
			this.moveBase(this.segmentBases[i], point.x, point.y, point.alpha);
			length += this.baseSpacing;
			//point = this.nextPosition(point, angle, this.baseSpacing);
		}
	},
	startDrawing : function() {
		this.callParent(arguments);
		this.bases = [];
		this.segmentBases = [];
	},
	stopDrawing : function() {
		this.callParent(arguments);
		_.each(this.bases, function(base) {
			base.remove();
		});
		this.bases = [];
	}
}, function() {
	Workspace.Tools.register('strand', Workspace.tools.secondary.StrandTool);
});
</pre>
</body>
</html>
