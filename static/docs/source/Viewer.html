<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='App-usr-enum-Viewer'>/**
</span> * Allows visualization of the results of enumeration for files in the ENJS format.
 */
Ext.define('App.usr.enum.Viewer', {
	extend : 'App.ui.D3Panel',
	requires : ['App.usr.nodal.StrandPreview'],
	mixins : {
		app : 'App.ui.Application'
	},
<span id='App-usr-enum-Viewer-property-editorType'>	editorType : 'Enumerator',
</span><span id='App-usr-enum-Viewer-cfg-autoRender'>	autoRender : false,
</span>
<span id='App-usr-enum-Viewer-property-fontSize'>	fontSize: 1,
</span><span id='App-usr-enum-Viewer-property-linkWidth'>	linkWidth: 2,
</span><span id='App-usr-enum-Viewer-property-arrowThreshold'>	arrowThreshold: 0.25,
</span>
<span id='App-usr-enum-Viewer-method-constructor'>	constructor : function() {
</span>		this.callParent(arguments);
		this.mixins.app.constructor.apply(this, arguments);
		this.on('afterrender', this.loadFile, this);
		this.complexWindows = {};
		this.previewPanels = {};

		this.reactionPanel = Ext.create('App.usr.enum.ReactionViewer')
		this.reactionWindow = Ext.create('Ext.window.Window',{
			items: [ this.reactionPanel ],
			layout: 'fit',
			width: 700,
			height: 200,
			border: false, bodyBorder: false,
		});
	},
<span id='App-usr-enum-Viewer-method-onLoad'>	onLoad : function() {
</span>		this.afterrender();
		this.reactionWindow.show();
	},
<span id='App-usr-enum-Viewer-method-redraw'>	redraw: function (translate,scale) {
</span>		

		this.callParent(arguments);
		this.node.selectAll('text.node-label').style('font-size',this.fontSize/scale+'em');
		this.link.style('stroke-width',this.linkWidth/scale);
		this.link.classed(&quot;link-reaction-noarrow&quot;, scale &lt; this.arrowThreshold)
		// this.legendg.attr(&quot;transform&quot;,&quot;translate(&quot;+ [(-translate[0]),(-translate[1])] +&quot;) scale(&quot;+ Math.min(1/scale,10) +&quot;)&quot;);
	},
<span id='App-usr-enum-Viewer-method-loadData'>	loadData: function() {
</span>		var data = this.data = JSON.parse(this.data);
		
		var initial_complexes = this.initial_complexes = _.reduce(data['initial_complexes'], function(memo, c) {
			memo[c.name] = true;
			return memo;
		}, {});

		var reactions = this.reactions = data['reactions'];

		var complexes;
		if (data['transient_complexes']) {
			complexes = _.map(data['resting_complexes'], function(x) {
				x.resting = true;
				return x;
			}).concat(_.map(data['transient_complexes'], function(x) {
				x.transient = true;
				return x;
			}));
		} else {
			complexes = _.map(data['resting_complexes'], function(x) {
				x.resting = true;
				return x;
			})
		}

		// Map complexes to their containing resting state
		var restingStateMap = this.restingStateMap = {};
		if (data['resting_states']) {
			for (var i = 0; i &lt; data['resting_states'].length; i++) {
				var resting_state = data['resting_states'][i];
				for (var j = 0; j &lt; resting_state.complexes.length; j++) {
					restingStateMap[resting_state.complexes[j]] = resting_state.name;
				}
			}
		}

		// Build data for the complex nodes
		var complexData = this.complexData = _.map(complexes, function(x, i) {
			x._type = 'complex';
			if (!!initial_complexes[x.name]) {
				x.initial = true;
			}
			if (!!restingStateMap[x.name]) {
				x.group = restingStateMap[x.name];
			} else {
				//x.group = x.name;
				x.group = null;
			}
			x._index = i;
			return x
		});
		var complexMap = this.complexMap = _.reduce(complexData, function(memo, x, i) {
			memo[x.name] = x;
			return memo;
		}, {});

		// Build data for the reaction noes
		var reactionData = this.reactionData = _.map(reactions, function(x, i) {
			x._type = 'reaction';
			x.name = 'reaction_' + i;
			x._index = i + complexData.length;
			x.fast = !(x.reactants.length &gt; 1);
			x.slow = !x.fast;
			x.group = complexMap[x.reactants[0]].group;
			for(var j=0;j&lt;x.reactants.length;j++) {
				if(complexMap[x.reactants[j]].group != x.group) {
					x.outgoing = true;
					x.group = null;
					break;
				}
			}
			if(!x.outgoing) {
				for(var j=0;j&lt;x.products.length;j++) {
					if(complexMap[x.products[j]].group != x.group) {
						x.outgoing = true;
						x.group = null;
						break;
					}
				}
			}	
			return x
		});
	},
<span id='App-usr-enum-Viewer-method-buildVis'>	buildVis : function() {
</span>		/* ****
		 * Visualization utilities
		 */

		// var curve = d3.svg.line().interpolate(&quot;cardinal-closed&quot;).tension(.85);

		var fill = d3.scale.category20();

		function nodeid(n) {
			return n.size ? &quot;_g_&quot; + n.group : n.name;
		}

		function linkid(l) {
			var u = nodeid(l.source), v = nodeid(l.target);
			return u &lt; v ? u + &quot;|&quot; + v : v + &quot;|&quot; + u;
		}
		
		var splinePathGenerator = d3.svg.line()
				.x(function(d) { return d.x; })
				.y(function(d) { return d.y; })
				.interpolate(&quot;bundle&quot;).tension(.6);

		function spline(e) {
			var points = e.dagre.points.slice(0);
			var source = dagre.util.intersectRect(e.source.dagre, points[0]);
			var target = dagre.util.intersectRect(e.target.dagre, points[points.length - 1]);
			points.unshift(source);
			points.push(target);

			// points = [source,target]
			return splinePathGenerator(points);
		}

		// --------------------------------------------------------

		/* ******************************
		 * Load data, build graph data structures
		 */

		this.loadData();
		var complexes = this.complexes,
			complexData = this.complexData,
			complexMap = this.complexMap,
			reactionData = this.reactionData,
			reactions = this.reactions;

		// Collect node data
		var nodes = _.map(complexData.concat(reactionData),function(x) {
			if(!x.edges) x.edges = [];
			return x;
		});

		// Build links
		var links = _.flatten(_.map(reactions, function(reaction) {
			return _.map(reaction.reactants, function(reactant) {
				var l = {
					'source' : complexMap[reactant],
					'target' : reaction
				};
				complexMap[reactant].edges.push(l);
				reaction.edges.push(l);
				return l; 
			}).concat(_.map(reaction.products, function(product) {
				var l = {
					'source' : reaction,
					'target' : complexMap[product]
				};
				reaction.edges.push(l);
				complexMap[product].edges.push(l);
				return l;
			}))
		}), /* true to flatten only one level */true);


		/* ******************************
		 * Build resting state groups thing
		 */
		
		var data = { nodes: complexMap, links: links };		

		/* ******************************
		 * Build visualization
		 */
		
		// One-time initialization
		var panel = this.getCanvas();
		var line_stroke = '#aaa'

		panel.append(&quot;svg:defs&quot;).selectAll(&quot;marker&quot;)
			.data([&quot;reaction-arrow&quot;])
			.enter()
				.append(&quot;svg:marker&quot;)
					.attr(&quot;id&quot;, String)
					.attr(&quot;viewBox&quot;, &quot;0 -5 10 10&quot;)
					.attr(&quot;refX&quot;, 0)
					.attr(&quot;refY&quot;, -1)
					.attr(&quot;markerWidth&quot;, 4)
					.attr(&quot;markerHeight&quot;, 4)
					.attr(&quot;orient&quot;, &quot;auto&quot;)
				.append(&quot;svg:path&quot;)
					.attr(&quot;d&quot;, &quot;M0,-5L10,0L0,5&quot;)
					.style('stroke', line_stroke)
					.style('fill', line_stroke);
			
		var linkg = this.linkg = panel.append(&quot;g&quot;);
  		var nodeg = this.nodeg = panel.append(&quot;g&quot;);
		var legendg = this.legendg = panel.append(&quot;g&quot;);

		var dr = 50,      // default point radius
    		cr = 100, 	 // default complex point radius
    		off = 15;    // cluster hull offset
		var dist = 50,
			nodePadding = 0; //5;
		
		
		var me = this;
		
		var colors, fills, strokes;
		fills = colors = {
			'reaction' : '',
			'reaction-fast' : '#01c',
			'reaction-slow' : '#a00',
			'transient' : '#0a0',
			'complex' : 'green',
			'resting' : 'green',
			'initial' : 'green',
		};
		strokes = {
			'reaction-fast' : '#fff',
			'reaction-slow' : '#fff',
			'transient' : '#fff',
			'complex' : '#fff',
			'initial' : 'yellow',
			'resting' : 'white',
		};
		
		function radius(d) {
			return d._type == 'complex' ? d.strands.length * 50 : dr
		}
		
		
		function highlightLinks(d) {
			var color = d3.scale.category20();

			panel.selectAll(&quot;path.link-reaction&quot;).classed(&quot;link-reaction-blurred&quot;,true);
			panel.selectAll(&quot;g.node&quot;).classed(&quot;node-blurred&quot;,true)

			panel.selectAll('g.node[name=&quot;'+d.name+'&quot;]').classed(&quot;node-blurred&quot;,false);


			// Select all paths that point out of this node
			panel.selectAll(&quot;path.link-reaction.source-&quot; + d.name).each(function(r, i) {
				// panel.selectAll(&quot;path.link-reaction.target-&quot; + r.target.name).classed(&quot;link-reaction-blurred&quot;,false);
				panel.selectAll('g.node[name=&quot;'+r.target.name+'&quot;]').classed(&quot;node-blurred&quot;,false);

			}).classed(&quot;link-reaction-blurred&quot;,false).classed(&quot;link-reaction-reactant&quot;,true).style(&quot;stroke&quot;,function(d) { 
				return color(d.target.name); 
			});

			// Select all paths that point into this node
			panel.selectAll(&quot;path.link-reaction.target-&quot; + d.name).each(function(r, i) {
				// panel.selectAll(&quot;path.link-reaction.source-&quot; + r.source.name).classed(&quot;link-reaction-blurred&quot;,false);
				panel.selectAll('g.node[name=&quot;'+r.source.name+'&quot;]').classed(&quot;node-blurred&quot;,false);

			}).classed(&quot;link-reaction-blurred&quot;,false).classed(&quot;link-reaction-product&quot;,true).style(&quot;stroke&quot;,function(d) { 
				return color(d.source.name); 
			});
		}

		function unhighlightLinks() {
			panel.selectAll(&quot;path.link-reaction&quot;).classed(&quot;link-reaction-blurred&quot;,false)
				.classed(&quot;link-reaction-reactant&quot;,false).classed(&quot;link-reaction-product&quot;,false).style(&quot;stroke&quot;,null);

			panel.selectAll(&quot;g.node&quot;).classed(&quot;node-blurred&quot;,false)

		}

		function buildLinks(linkg,net,me) {
			var linkSel = linkg.selectAll(&quot;path.link-reaction&quot;).data(net.links, linkid);
			linkSel.exit().remove();
			linkSel.enter().append(&quot;path&quot;)
				.attr(&quot;class&quot;, function(d) {
				var cls = [&quot;link-reaction&quot;]
				cls.push(&quot;source-&quot; + d.source.name);
				cls.push(&quot;target-&quot; + d.target.name);
				return cls.join(' ');
			}).attr(&quot;x1&quot;, function(d) {
				return d.source.x;
			}).attr(&quot;y1&quot;, function(d) {
				return d.source.y;
			}).attr(&quot;x2&quot;, function(d) {
				return d.target.x;
			}).attr(&quot;y2&quot;, function(d) {
				return d.target.y;
			}).style(&quot;stroke-width&quot;, function(d) {
				return d.size || 1;
			}).style(&quot;fill&quot;,&quot;none&quot;)
			.classed(&quot;link-reaction-noarrow&quot;,false);

			return linkSel;
		}

		function buildNodes (nodeg,net,me) {
			var nodeSel = nodeg.selectAll(&quot;g.node&quot;).data(net.nodes, nodeid);
			nodeSel.exit().remove();
			nodeSel.enter().append(&quot;g&quot;)
				.attr('class', 'node')
				.attr(&quot;transform&quot;, function(d) {
				return &quot;translate(&quot; + d.x + &quot;,&quot; + d.y + &quot;)&quot;;
			})
			.attr('name',function (d) {
				return d.name;
				// switch (d._type) {
				// 	case 'complex':
				// 		return 'complex_'+d.name;
				// 	case 'reaction':
				// 		return d.name;
				// }
			})
			.on('mouseover', highlightLinks)
			.on('mouseout', unhighlightLinks)
			.on('dblclick', function(d) {
				if (d._type == 'complex') {
					me.renderPreview(d, this);
					d3.event.stopPropagation();
				} else if (d._type=='reaction') {
					me.showReaction(d);
				}
			})

			nodeSel.append('text').attr('class', 'node-label')
			.attr(&quot;dx&quot;, function(d) {
				return radius(d) + 5;
			}).attr(&quot;dy&quot;, &quot;.35em&quot;).text(function(d) {
				if (d._type == 'complex') {
					return d.name;
				} else {
					return '';
				}
			});

			nodeSel.append('rect')
			.attr(&quot;class&quot;, function(d) {
				switch (d._type) {
					case 'complex':
						return 'complex ' + (d.resting ? 'complex-resting' : 'complex-transient');
					case 'reaction':
						return '' + (d.fast ? 'reaction-fast' : 'reaction-slow');
					default:
						if (d.size != 0) {
							return 'resting-state';
						}
						return '';
				}
			})
			.attr(&quot;width&quot;, radius)
			.attr(&quot;height&quot;, radius)
			.attr(&quot;rx&quot;, function(d) {
				switch (d._type) {
					case 'complex': return 10;
					default: return d.size ? d.size + dr : dr + 1;
				}
			})
			.attr(&quot;ry&quot;, function(d) {
				switch (d._type) {
					case 'complex': return 10;
					default: return d.size ? d.size + dr : dr + 1;
				}
			});

			nodeSel.each(function(d) {
			    var bbox = this.getBBox();
			    d.bbox = bbox;
			    d.width = bbox.width + (2 * nodePadding);
			    d.height = bbox.height + (2 * nodePadding);
			  });

			return nodeSel;
		}

		function buildLegend(legendg,me) {
			var legend = legendg.selectAll('g.legend').data([{
				name : 'Resting Complex',
				type : 'resting'
			}, {
				name : 'Transient Complex',
				type : 'transient'
			}, {
				name : 'Fast (unimolecular) Reaction',
				type : 'reaction-fast'
			}, {
				name : 'Slow (bimolecular) Reaction',
				type : 'reaction-slow'
			}, {
				name : 'Initial Complex',
				type : 'initial'
			}]).enter().append('g').attr('class', 'legend').attr('transform', function(d, i) {
				return &quot;translate(15,&quot; + (20 * i + 15) + &quot;)&quot;
			});

			legend.append('circle').attr('fill', function(d) {
				return fills[d.type]
			}).attr('stroke', function(d) {
				return strokes[d.type]
			}).attr('r', 8).attr('stroke-width', 2)
			
			legend.append('text').style('fill', '#111').text(function(d) {
				return d.name
			}).attr(&quot;dx&quot;, function(d) {
				return radius(d) + 5
			}).attr(&quot;dy&quot;, &quot;.35em&quot;)

			return legend;
		}

		function init() {

			var net = {
				links: links,
				nodes: nodes,
			};

			// Build selections for links and nodes
			me.link = buildLinks(linkg,net,me)
			me.node = buildNodes(nodeg,net,me)

			dagre.layout()
				.nodeSep(50)
				.edgeSep(10)
				.rankSep(50)
				.nodes(net.nodes)
				.edges(net.links)
				.debugLevel(1)
				.run();

			// Ensure that we have at least two points between source and target
			me.link.each(function(d) {
				var points = d.dagre.points;
				if (!points.length) {
					var s = e.source.dagre;
					var t = e.target.dagre;
					points.push({
						x: Math.abs(s.x - t.x) / 2,
						y: Math.abs(s.y + t.y) / 2
					});
				}

				if (points.length === 1) {
					points.push({
						x: points[0].x,
						y: points[0].y
					});
				}
			});

			me.node.attr(&quot;transform&quot;, function(d) { 
				return 'translate('+ (d.dagre.x - d.dagre.width/2) +','+ (d.dagre.y - d.dagre.height/2) +')'; 
			});

			me.link
			// Set the id. of the SVG element to have access to it later
			    .attr('id', function(e) { return e.dagre.id; })
			    .attr(&quot;d&quot;, function(e) { return spline(e); });


			var svgBBox = panel.node().getBBox();
			panel.attr(&quot;width&quot;, svgBBox.width + 10);
			panel.attr(&quot;height&quot;, svgBBox.height + 10);
			me.rect.attr(&quot;width&quot;, svgBBox.width + 10);
			me.rect.attr(&quot;height&quot;, svgBBox.height + 10);
			
		}	
		
		// Construct Legend
		me.legend = buildLegend(legendg,me);

		init();

	},
<span id='App-usr-enum-Viewer-method-showReaction'>	showReaction: function (d) {
</span>		if(d._type=='reaction')	{
			var me = this,
				reactants = _.map(d.reactants, function(r) { return me.complexMap[r] }),
				products = _.map(d.reactants, function(r) { return me.complexMap[r] });

			this.reactionPanel.setValue(d,reactants,products)
		}
	},
<span id='App-usr-enum-Viewer-method-renderPreview'>	renderPreview: function(d,node) {
</span>		var data = !!d['dot-paren-full'] ? d['dot-paren-full'] : d['dot-paren'],
			panel = d3.select(node);

		this.previewPanels[d.name] = StrandPreview(panel).width(d.width).height(d.height)
		this.complexWindows[d.name] = this.previewPanels[d.name] (panel.data([data]));
	},
<span id='App-usr-enum-Viewer-method-showWindow'>	showWindow : function(d, node) {
</span>		if (!this.complexWindows[d.name]) {
			var strands = d['strands'];

			// this.previewPanels[d.name] = Ext.create('App.usr.nodal.StrandPreview', {
			// 	adjacencyMode : 1,
			// 	cls : 'simple-header',
			// 	title : strands.join(&quot; + &quot;),
			// 	autoRender : true,
			// 	value : '',
			// });
			this.previewPanels[d.name] = Ext.create('App.ui.StrandPreview', {
				cls : 'simple-header',
				title : strands.join(&quot; + &quot;),
				autoRender : true,
				value : '',
				adjacencyMode: 2,
			});

			this.complexWindows[d.name] = Ext.create('Ext.tip.ToolTip', {
				target : node,
				anchor : 'left',
				constrainPosition : true,
				items : [this.previewPanels[d.name]],
				layout : 'fit',
				autoHide : false,
				closable : true,
				closeAction : 'hide',
				width : 200,
				height : 200,
				draggable : true,
				title : &quot;Complex: &quot; + d.name,
				resizable : true,
				autoRender : true,
			});

			this.complexWindows[d.name].show();
			this.previewPanels[d.name].setTitle(strands.join(&quot; + &quot;))
			this.previewPanels[d.name].setValue(!!d['dot-paren-full'] ? d['dot-paren-full'] : d['dot-paren'], strands);
		} else {
			if (this.complexWindows[d.name].isVisible()) {
				this.complexWindows[d.name].hide();
			} else {
				this.complexWindows[d.name].show();
			}
		}
	}
});

Ext.define('App.ui.PlusPanel', {
	extend: 'App.ui.D3Panel',
	autoRender: true,
	border: false, bodyBorder: false,
	pan: false, zoom: false,
	buildVis: function() {
		var panel = this.getCanvas(),
			c = d3.svg.symbol().type('cross');
		this.path = panel.append('path')
			.attr('d', c())
			.attr(&quot;transform&quot;, &quot;translate(&quot; + (this.getWidth() / 2) + &quot;,&quot; + (this.getHeight() / 2) + &quot;)&quot;)
	},
	updateVis: function() {
		this.path.attr(&quot;transform&quot;, &quot;translate(&quot; + (this.getWidth() / 2) + &quot;,&quot; + (this.getHeight() / 2) + &quot;)&quot;)
	},

	width: 50,
});

Ext.define('App.ui.ArrowPanel', {
	extend: 'App.ui.D3Panel',
	autoRender: true,
	border: false, bodyBorder: false,
	pan: false, zoom: false,
	buildVis: function() {
		var panel = this.getCanvas();

		panel.append(&quot;svg:defs&quot;).selectAll(&quot;marker&quot;)
			.data([&quot;reaction-arrow-large&quot;])
			.enter()
				.append(&quot;svg:marker&quot;)
					.attr(&quot;id&quot;, String)
					.attr(&quot;viewBox&quot;, &quot;0 -5 10 10&quot;)
					.attr(&quot;refX&quot;, 0)
					.attr(&quot;refY&quot;, -1)
					.attr(&quot;markerWidth&quot;, 4)
					.attr(&quot;markerHeight&quot;, 4)
					.attr(&quot;orient&quot;, &quot;auto&quot;)
				.append(&quot;svg:path&quot;)
					.attr(&quot;d&quot;, &quot;M0,-5L10,0L0,5&quot;)
					.style('stroke', '#000')
					.style('fill', '#000');
			
		this.path = panel.append('path').attr(&quot;d&quot;,&quot;M-5,0L5,0&quot;).attr(&quot;marker-end&quot;,&quot;url(#reaction-arrow-large)&quot;)
			.style('stroke-width','2px')
			.style('stroke', '#000')
			.style('fill', '#000');
	},
	updateVis: function() {
		this.path.attr(&quot;transform&quot;, &quot;translate(&quot; + (this.getWidth() / 2) + &quot;,&quot; + (this.getHeight() / 2) + &quot;)&quot;)
	},
	width: 50,
});


Ext.define('App.usr.enum.ReactionViewer', {
	extend : 'Ext.panel.Panel',
	requires : ['App.usr.nodal.StrandPreview'],
	layout: 'hbox',
	align: 'stretch',
	border: false, bodyBorder: false,
	
	constructor : function() {
		this.reactant1 = Ext.create('App.ui.StrandPreview',{
			cls : 'simple-header',
			title : ' ',
			autoRender : true,
			value : '',
			adjacencyMode: 2,
			flex: 1,
			border: false, bodyBorder: false,
		});
		this.reactant_plus = Ext.create('App.ui.PlusPanel');
		this.reactant2 = Ext.create('App.ui.StrandPreview',{
			cls : 'simple-header',
			title : ' ',
			autoRender : true,
			value : '',
			adjacencyMode: 2,
			flex: 1,
			border: false, bodyBorder: false,
		});

		this.reaction_arrow = Ext.create('App.ui.ArrowPanel');

		this.product1 = Ext.create('App.ui.StrandPreview',{
			cls : 'simple-header',
			title : ' ',
			autoRender : true,
			value : '',
			adjacencyMode: 2,
			flex: 1,
			border: false, bodyBorder: false,
		})
		this.product_plus = Ext.create('App.ui.PlusPanel');
		this.product2 = Ext.create('App.ui.StrandPreview',{
			cls : 'simple-header',
			title : ' ',
			autoRender : true,
			value : '',
			adjacencyMode: 2,
			flex: 1,
			border: false, bodyBorder: false,
		})

		Ext.apply(this,{
			layout: {
		    	type: 'hbox',
		    	align: 'stretch'
		    },
		    defaults: {
		    	bodyBorder: false,
		    	border: false,
		    },
			items: [
				this.reactant1,
				this.reactant_plus,
				this.reactant2,
				this.reaction_arrow,
				this.product1,
				this.product_plus,
				this.product2,
			]
		});

		this.callParent(arguments)
	},
	setValue: function(reaction,reactants,products) {
		var reactantViews = [this.reactant1,this.reactant2],
			productViews = [this.product1, this.product2];

		for(var i=0; i&lt;Math.min(reactantViews.length,reactants.length); i++) {
			var d = reactants[i],
				structure = !!d['dot-paren-full'] ? d['dot-paren-full'] : d['dot-paren'],
				strands = d['strands'];

			reactantViews[i].setValue(structure,strands);
			reactantViews[i].setTitle(strands.join('+'));

		}
		if(reactants.length&lt;2) { this.reactant2.hide(); this.reactant_plus.hide(); }
		else { this.reactant2.show(); this.reactant_plus.show(); }

		for(var i=0; i&lt;Math.min(productViews.length,products.length); i++) {
			var d = reactants[i],
				structure = !!d['dot-paren-full'] ? d['dot-paren-full'] : d['dot-paren'],
				strands = d['strands'];		

			productViews[i].setValue(structure,strands);
			productViews[i].setTitle(strands.join('+'));
		}

		if(products.length&lt;2) { this.product2.hide(); this.product_plus.hide(); }
		else { this.product2.show(); this.product_plus.show(); }
	}
});
</pre>
</body>
</html>
