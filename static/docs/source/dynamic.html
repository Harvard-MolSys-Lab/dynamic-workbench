<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">if( typeof require === 'function') {
	_ = require('underscore');
	DNA = require('./dna-utils.js').DNA;
} else {
	module = {}; module.exports = {};
}
if( typeof App == 'undefined') {
	App = {};
}

App.dynamic = module.exports = (function(_,DNA) {
<span id='_'>	/**
</span>	 * @class _
	 * Provides some additional methods inspired by _.js
	 */
	_.mixin({
<span id='_-method-serialize'>		/**
</span>		 * Returns a deep copy of the provided object, which will be a simple 
		 * object. Recursive structures are intelligently handled. If objects
		 * have their own `serialize` method defined, that is used.
		 * @param {Mixed} o
		 * @param {Boolean} isChild 
		 */
		serialize: function(o,isChild) {
			isChild || (isChild = false);
			
			// if o defines its own serialization function (ie: for higher level objects), use that
			if (o &amp;&amp; o.serialize &amp;&amp; _.isFunction(o.serialize)) {
				return o.serialize(isChild)
			}

			// serialize an array
			if (_.isArray(o)) {
				var r = [];
				for (var i = 0, l = o.length; i &lt; l; i++) {
					r.push(_.serialize(o[i], true));
				}
				return r;
			}

			// serialize a simple object hash (allow for complex objects contained in the hash)
			if (_.isObject(o)) {
				var r = {};
				for (var p in o) {
					if(_.has(o,p)) {
						r[p] = _.serialize(o[p], true);
					}
				}
				return r;
			}

			// no serialization needed; Ext will take care of the .toString()s
			return o;
		},
<span id='_-method-copy'>		/**
</span>		 * Produces a copy of source which does not include properties on the prototype chain.
		 * @param {Object} source
		 * @returns {Object} copy
		 */
		copy : function(source) {
			return _.copyTo({}, source)
		},
<span id='_-method-copyTo'>		/**
</span>		 * Copies properties from `source` which do not appear on the prototype chain
		 * to `destination`
		 * @param {Object} destination
		 * @param {Object} source
		 * @returns {Object} destination
		 */
		copyTo : function(destination, source) {
			_.each(source, function(value, key) {
				if(_.has(source,key)) {
					destination[key] = value;
				}
			});
			return destination;
		},
<span id='_-method-copyWith'>		/**
</span>		 * Returns a {@link _#copy copy} of `source`, extended with values in `change`
		 * @param {Object} source Object to copy
		 * @param {Object} change Additional properties to over write in `source
		 * @returns {Object} destination
		 */
		copyWith : function(source, change) {
			return _.extend(_.copy(source),change);
		},
		deepClone : function(source) {
			var dest;
			if(_.isObject(source)) {
				dest = {};
				_.each(source, function(value, key) {
					dest[key] = _.deepClone(value);
				});
			} else if(_.isArray(source)) {
				dest = _.map(source, _.deepClone);
			} else {
				dest = source;
			}
			return dest;
		}
	});

	/* ***************************************************************** */

<span id='App-dynamic-Motif'>	/**
</span>	 * @class App.dynamic.Motif
	 * Represents a single motif
	 */
	function Motif(config) {
		if(!config.library) {
			throw new DynamlError({
				type: 'no library',
				message: 'Motif &lt;%= motif.getName() %&gt; instantiated without library reference',
				motif: this,
				config: config,
			});
		}
		
		// Compile recursively if necessary
		if(config.nodes) {
			
			// // Import any external motifs
			// // TODO: check if there are internal motifs with the same name; if so, that'll create a DynamlError now
			// if(config.externalMotifs) {
				// if(!config.motifs) {
					// config.motifs = [];
				// }
				// config.motifs = config.externalMotifs.concat(config.motifs);
			// }
				
			var recursive = Library.fromMotif(config);
			try {
				recursive = recursive.compile();
			} catch (e) {
				if(e.message) {
					e.message = [&quot;In motif&quot;,config.name,&quot;:\n&quot;,e.message].join(' ');
				}
				throw new DynamlError(e);
			}
			_.extend(this,recursive.toMotif());
			delete config.nodes;
			delete config.motifs;
			delete config.imports;
			if(!this.structure) {
				
			}
		} else {
			delete config.externalMotifs;
		}

		// Apply configuration options with defaults to this object
		_.copyTo(this, config);
		_.defaults(this, {
<span id='App-dynamic-Motif-cfg-name'>			/**
</span>			 * @cfg
			 */
			name : '',
<span id='App-dynamic-Motif-cfg-type'>			/**
</span>			 * @cfg
			 * Type of motif to create. Currently one of: `&quot;initiator&quot;` or `&quot;hairpin&quot;`
			 */
			type : 'hairpin',
			polarity : 0,
<span id='App-dynamic-Motif-cfg-isInitiator'>			/**
</span>			 * @cfg
			 */
			isInitiator : false,
		});
		


		this.isInitiator = this.isInitiator || this.type == 'initiator';
				
		// Thread structures to appropriate strands
		var strandStructures = {};
		if(this.structure) {
			var structures = this.structure;
			if(!_.isArray(structures)) {
				structures = [structures];
			}
			
			structures = _.map(structures,function(struct) {
				/* 
				 * returns an object mapping strand indicies to the sub-structures (separated by +) of struct
				 * allows for the case where the structure(s) refer to a different permutation of strands than
				 * order of strands in the motif
				 */
				return Structure.parseMultiple(struct);
			});
			
			// TODO: deal with multiple structures
			strandStructures = _.first(structures);
		}
		if(this.strands) {
			this.strands = _.map(this.strands,function(strand,i) {
				if(strand.name &amp;&amp; strandStructures[strand.name]) {
					strand.structure = strandStructures[strand.name];
				} else if(strandStructures[i]) {
					strand.structure = strandStructures[i];
				}
				strand.library = this.library;
				return new Strand(strand); 
			},this);
		} else if(this.domains) {
			var structure = strandStructures[0]; 
			this.strands = [
				new Strand({
					library: this.library,
					domains: this.domains,
					structure: structure,
				})
			];
		}
		

<span id='App-dynamic-Motif-property-each'>		/**
</span>		 * @property {App.dynamic.Domain[]}
		 * @private
		 * Use #getDomains
		 */
		// this.domains = _.map(this.domains, function(domain) {
			// return new Domain(domain);
		// });

		_.each(this.getDomains(), function(domain) {
			if(!domain.polarity) {
				domain.polarity = 1;
				// throw new DynamlError({
					// type : 'unspecified motif domain polarity',
					// message : _.template('Domain &lt;%= domain %&gt; in motif &lt;%= motif %&gt; has no polarity specified. ' + //
					 // 'Polarities are required for domains specified in motifs.', {
						// motif : this.name,
						// domain : domain.name,
					// }),
					// motifs : [this],
					// domain : domain,
				// });
			}
		}, this);
		
<span id='App-dynamic-Motif-property-polarity'>		/**
</span>		 * @property
		 */
		this.polarity = DNA.parsePolarity(this.polarity);

		this.library.register('motif',this.name, this);
	}


	Motif.prototype = {
<span id='App-dynamic-Motif-method-instantiate'>		/**
</span>		 * Generates a new {@link App.dynamic.Node node} which inherits the properties of this motif
		 * @return {App.dynamic.Node} node
		 */
		instantiate : function(config) {
			config.motif = this.name;
			return new Node(config);
		},
<span id='App-dynamic-Motif-method-getSegments'>		/**
</span>		 * Gets all {@link App.dynamic.Segment segments} associated with this motif/node
		 * @returns {App.dynamic.Segment}
		 */
		getSegments : function() {
			return _.flatten(_.map(this.getDomains(), function(domain) {
				return domain.getSegments();
			}));
		},
<span id='App-dynamic-Motif-method-getDomains'>		/**
</span>		 * Gets all {@link App.dynamic.Domain domains} associated with this motif/node
		 * @returns {App.dynamic.Domain[]} domains
		 */
		getDomains : function() {
			return _.flatten(_.map(this.getStrands(),function(strand) {
				return strand.getDomains();
			}))
		},
		getStrands : function() {
			return this.strands;
		},
<span id='App-dynamic-Motif-method-getDomain'>		/**
</span>		 * Gets the {@link App.dynamic.Domain domain} with the provided name
		 * @param {String} name
		 * @returns {App.dynamic.Domain} domain
		 */
		getDomain : function(name) {
			return _.find(this.getDomains(), function(dom) {
				return dom.name == name;
			});
		},
		getName : function() {
			return this.name;
		},
		serialize: function() {
			var out = _.copy(this);
			if(out.library) { delete out.library; }
			return _.serialize(out);
		}
	}
	_.extend(Motif, {
<span id='App-dynamic-Motif-static-method-nextName'>		/**
</span>		 * Gets the next available motif name.
		 * @static
		 */
		nextName : function() {
			var motifIndex = 0;
			return function() {
				motifIndex++;
				return &quot;m&quot; + motifIndex;
			}
		}(),
		motifs : {},
<span id='App-dynamic-Motif-static-method-register'>		/**
</span>		 * Registers the given motif by name so it can be retrieved later by #get
		 * @static
		 * @param {String} name
		 * @param {App.dynamic.Motif} motif
		 */
		register : function(name, motif) {
			this.motifs[name] = motif;
			return motif;
		},
<span id='App-dynamic-Motif-static-method-get'>		/**
</span>		 * Gets the motif with the given name previously {@link #register registered}.
		 * @static
		 * @param {String/App.dynamic.Motif} name If passed a string, a lookup will convert it to a Motif or `null`; if passed a Motif, the Motif will be returned unchanged
		 */
		get : function(name) {
			if( name instanceof Motif) {
				return name;
			} else {
				return this.motifs[name];
			}
		},
	});

	/* ***************************************************************** */

<span id='App-dynamic-Node'>	/**
</span>	 * @class App.dynamic.Node
	 * Represents a single Node.
	 * @extends App.dynamic.Motif
	 */
	function Node(config) {
		
		if(!config.library) {
			throw new DynamlError({
				type: 'no library',
				message: 'node instantiated without library reference; can\'t decode motif',
				node: this,
				config: config,
			});
		}
		this.library = config.library;
		
		// Inherit motif if configured
		if(config.motif) {
			var motif = config.library.getMotif(config.motif);
<span id='App-dynamic-Node-cfg-motif'>			/**
</span>			 * @cfg {String/App.dynamic.Motif} motif
			 * Name or reference to a {@link App.dynamic.Motif motif} from
			 * which this node inherits.
			 */
			_.copyTo(this, motif);
			
		}

		// // Save domains from the motif in a hash table by their names
		// // TODO: the motif really should do this.
		// var motifDomainsMap = _.reduce(this.getDomains() || [], function(memo, domain) {
			// memo[domain.name] = domain;
			// return memo;
		// }, {});

		// Capture any domain/strand properties specified on the nodes
		var nodeDomainProperties = _.reduce(config.domains || [], function(memo, domain) {
			memo[domain.name] = domain;
			return memo;
		}, {});
		
		var nodeStrandProperties = _.reduce(config.strands || [], function(memo,strand) {
			memo[strand.name] = strand;
			return memo;
		},{});
		
		delete config.domains;
		delete config.strands;

		// Apply configuration options with defaults to this object
		_.copyTo(this, config), _.defaults({
<span id='App-dynamic-Node-cfg-type'>			/**
</span>			 * @cfg {String} [type='hairpin']
			 * Type of motif to create. Currently one of: `&quot;initiator&quot;` or `&quot;hairpin&quot;`
			 */
			type: 'hairpin',
<span id='App-dynamic-Node-cfg-polarity'>			/**
</span>			 * @cfg {Number} [polarity=0]
			 */
			polarity : 0,
		});
		
		
		
		this.strands = _.map(this.strands,function(strand,i) {
			
			// See if additional strand properties for this strand were specified by the node
			strand = _.copyWith(strand,nodeStrandProperties[strand.name] || {});
			// (must always copy else assigning to strand screws things up)
			
			// if(nodeStrandProperties[strand.name]) {
			// }

			// See if additional domain properties for this strand were specified by the node			
			strand.domains = _.map(strand.domains, function(domain) {
		
				// Find domains with matching identities in motif
				//if(domain.identity &amp;&amp; motifDomainsMap[domain.identity]) {
				//	domain = _.extend(_.copy(motifDomainsMap[domain.identity]), domain);
				//}
				//domain.node = this;
				
				if(nodeDomainProperties[domain.name]) {
					domain = _.copyWith(domain,nodeDomainProperties[domain.name]);
				}
				
				return domain //new Domain(domain);
			
			}, this);
			
			strand.name || (strand.name = (this.strands.length &gt; 1) ? 'strand'+i : '');
			strand.library = this.library;
			
			return new Strand(_.copyWith(strand,{ node: this }));
		},this);
		
		// Construct Domain objects from specifications
		// this.domains = 		_.map(this.domains, function(domain) {
// 		
			// // Find domains with matching identities in motif
			// if(domain.identity &amp;&amp; motifDomainsMap[domain.identity]) {
				// domain = _.extend(_.copy(motifDomainsMap[domain.identity]), domain);
			// }
			// domain.node = this;
			// return new Domain(domain);
// 		
		// }, this);
		
		// TODO: compiler should do this.
		if(this.isInitiator) {
			this.polarity = -1;
		}
		
		// Apply post-processor
		if(Node.types[this.type]) {
			Node.types[this.type](this);
		}

		this.library.register('node',this.name, this);
	}


	_.extend(Node.prototype, Motif.prototype);
	_.extend(Node.prototype, {
		polarity: 0,
<span id='App-dynamic-Node-method-getPolarity'>		/**
</span>		 * Returns the absolute polarity of this node
		 * @returns {Number} node polarity
		 */
		getPolarity : function() {
			return this.polarity;
		},
<span id='App-dynamic-Node-method-getConstraintMatrix'>		/**
</span>		 * Produces a constraint matrix; essentially a hash describing the relationship between each
		 * of the {@link App.dynamic.Segment#id segment IDs} of the {@link App.dynamic.Segment segments}
		 * associated with this node.
		 *
		 * Result:
		 *     constraints[leftSegment ID][rightSegment ID] == -1 // =&gt; leftSegment is complementary to rightSegment
		 *     constraints[leftSegment ID][rightSegment ID] == 1  // =&gt; leftSegment has the same identity as rightSegment
		 *     constraints[leftSegment ID][rightSegment ID] == null // =&gt; leftSegment and rightSegment are orthogonal
		 *
		 * @returns {Object} constraints. See description.
		 */
		getConstraintMatrix : function() {
			var segments = this.getSegments();

			// fold all segments into a matrix of constraints
			// for each segment (= leftSegment):
			return _.reduce(segments, function(constraints, leftSegment) {

				/*
				 * iterate through each other segment (= rightSegment)
				 * producing a hash mapping the segment ID of each other
				 * segments which shares leftSegment's identity to the
				 * product of leftSegment's polarity and that segment's
				 * polarity.
				 */

				constraints[leftSegment.getId()] = _.reduce(segments, function(memo, rightSegment) {

					// if another segment shares leftSegment's identity, but isn't leftSegment
					if((leftSegment.getIdentity() == rightSegment.getIdentity()) &amp;&amp; (leftSegment.getId() != rightSegment.getId())) {

						// set constraints[leftSegment ID][rightSegment ID] to product of polarities
						memo[rightSegment.getId()] = rightSegment.polarity * leftSegment.polarity;
					}
					return memo;
				}, {});
				return constraints;
			}, {});
		},
<span id='App-dynamic-Node-method-getSegmentIdentityMatrix'>		/**
</span>		 * Generates a hash table mapping each unique segment identity
		 * to a list of segments in this node with that identity.
		 */
		getSegmentIdentityMatrix : function() {
			var segments = this.getSegments(), identities = {};

			function checkout(identity, segment) {
				if(!identities[identity]) {
					identities[identity] = [];
				}
				identities[identity].push(segment);
			}


			_.each(segments, function(segment) {
				checkout(segment.identity, segment);
			});
			return identities;

		},
		getStructure: function() {
			return Structure.join(_.map(this.getStrands(),function(strand) {
				return strand.getStructure();
			}));
		},
<span id='App-dynamic-Node-method-getAnnotatedStructure'>		/**
</span>		 * Returns object like:
		 * 	[{strand: {Strand}, structure:strand.getAnnotatedStructure()},...]
		 */
		getAnnotatedStructure: function() {
			return _.map(this.getStrands(),function(strand) {
				return {strand: strand, structure: strand.getAnnotatedStructure()};
			});
		},
		getSegmentwiseStructure: function() {
			return Structure.join(_.map(this.getStrands(),function(strand) {
				return strand.getSegmentwiseStructure();
			}));
		},
		serialize: function() {
			var out = _.copy(this);
			if(out.motif) { out.motif = out.motif.getName(); }
			if(out.library) { delete out.library; }
			return _.serialize(out);
		}
	});

	_.extend(Node, {
<span id='App-dynamic-Node-static-property-types'>		/**
</span>		 * Hash of post-processors to be passed the node at the end of the constructor.
		 * 
		 * Current types:
		 * -	`hairpin`
		 * 
		 * @static
		 */
		types: {
			'hairpin': function(node) {
				_.each(node.getDomains(), function(domain) {
					if(domain.role=='input') {
						// all segments other than toehold will be duplex
						_.each(domain.getSegments(),function(segment) {
							segment.duplex = (segment.role != 'toehold');
						});
					} else if(domain.role=='output') {
						if(domain.type == 'loop') {
							// segments will be duplex if (role != 'loop') and (role of previous segment != 'loop' if role == 'clamp')
							var previousRole = ''
							_.each(domain.getSegments(),function(segment) {
								segment.duplex = !(segment.role == 'loop' || (segment.role == 'clamp' &amp;&amp; previousRole == 'loop'));
								previousRole = segment.role;
							});
						} else if(domain.type == 'tail') {
							// segments will be duplex if (role == 'toehold') or (role == 'clamp' and previous role == 'toehold')
							var previousRole = ''
							_.each(domain.getSegments(),function(segment) {
								segment.duplex = (segment.role == 'toehold' || (segment.role == 'clamp' &amp;&amp; previousRole == 'toehold'));
								previousRole = segment.role;
							});
						}
					}
				});
			}
		},
		
		nodes : {},
<span id='App-dynamic-Node-static-method-register'>		/**
</span>		 * Registers the given node by name so it can be retrieved later by #get
		 * @static
		 * @param {String} name
		 * @param {App.dynamic.Node} motif
		 */
		register : function(name, nodes) {
			this.nodes[name] = nodes;
			return nodes;
		},
<span id='App-dynamic-Node-static-method-get'>		/**
</span>		 * Gets the node with the given name previously {@link #register registered}.
		 * @static
		 * @param {String/App.dynamic.Node} node If passed a string, a lookup will convert it to a Node or `null`; if passed a Node, the Node will be returned unchanged
		 */
		get : function(name) {
			if( name instanceof Node) {
				return name;
			} else {
				return this.nodes[name];
			}
		},
	})

	/* ***************************************************************** */

<span id='App-dynamic-Strand'>	/**
</span>	 * @class App.dynamic.Strand
	 */
	function Strand(config) {
		if(!config.library) {
			throw new DynamlError({
				type: 'no library',
				message: 'strand instantiated without library reference',
				strand: this,
				config: config,
			});
		}
		
		// Apply configuration options with defaults to this object
		_.copyTo(this, config); 
		_.defaults(this, {
		});
		
<span id='App-dynamic-Strand-property-domains'>		/**
</span>		 * @property {App.dynamic.Domain[]}
		 * @private
		 * Use #getDomains
		 */
		this.domains = _.map(this.domains, function(domain) {
			return new Domain(_.copyWith(domain,{ strand: this, library: this.library, }));
			// return new Domain(_.copyTo(_.copy(domain),{
				// strand: this
			// }));
		},this);
		
<span id='App-dynamic-Strand-property-structure'>		/**
</span>		 * @property {App.dynamic.Structure}
		 * @private
		 * Use #getStructure or #getSegmentwiseStructure
		 */
		this.structure = new Structure(this.structure);
		
<span id='App-dynamic-Strand-property-polarity'>		/**
</span>		 * @property {Number}
		 * @private
		 * Use #getPolarity or #getAbsolutePolarity
		 */
		this.polarity = DNA.parsePolarity(this.polarity);
		if(this.polarity == 0) {
			this.polarity = 1;
		}
	}


	Strand.prototype = {
<span id='App-dynamic-Strand-method-getNode'>		/**
</span>		 * @return {App.dynamic.Node} node
		 */
		getNode: function() {
			return this.node;
		},
<span id='App-dynamic-Strand-method-getName'>		/**
</span>		 * @return {String} name
		 */
		getName : function() {
			return this.name;
		},
<span id='App-dynamic-Strand-method-getQualifiedName'>		/**
</span>		 * Returns the name of this strand, or the name of the node
		 * which this represents, if there is only one strand in the
		 * node.
		 * @return {String} name
		 */
		getQualifiedName : function() {
			var n =[this.getNode().name];
			if(this.getName()) {n.push(this.getName())} 
			return n.join('_');
		},
<span id='App-dynamic-Strand-method-getAbsolutePolarity'>		/**
</span>		 * Returns the absolute polarity of this strand
		 * absolute polarity = (relative strand polarity) * (node polarity)
		 * @returns {Number} polarity -1 = 3' -&gt; 5', 1 = 5' -&gt; 3', 0 = undetermined
		 */
		getAbsolutePolarity : function() {
			if(this.node) {
				return this.node.getPolarity() * this.getPolarity();
			} else {
				return this.getPolarity();
			}
		},
<span id='App-dynamic-Strand-method-getPolarity'>		/**
</span>		 * Returns the polarity of this strand, relative to the 
		 * {@link App.dynamic.Node#polarity node polarity}
		 * @param {Number} polarity -1 = 3' -&gt; 5', 1 = 5' -&gt; 3', 0 = undetermined
		 */
		getPolarity : function() {
			return this.polarity;
		},
<span id='App-dynamic-Strand-method-getSegments'>		/**
</span>		 * @inheritdoc App.dynamic.Node#getSegments
		 */
		getSegments : function() {
			return _.flatten(_.map(this.getDomains(), function(domain) {
				return domain.getSegments();
			}));
		},
<span id='App-dynamic-Strand-method-getDomains'>		/**
</span>		 * @inheritdoc App.dynamic.Node#getDomains
		 */
		getDomains : function() {
			return this.domains;
		},
<span id='App-dynamic-Strand-method-getDomain'>		/**
</span>		 * @inheritdoc App.dynamic.Node#getDomain
		 */
		getDomain : function(name) {
			return _.find(this.getDomains(), function(dom) {
				return dom.name == name;
			});
		},
<span id='App-dynamic-Strand-method-getSegmentLengths'>		/**
</span>		 * Returns a list of lengths of the segments in the strand, in bases
		 * @return {Number[]}
		 */
		getSegmentLengths: function() {
			return _.map(this.getSegments(),function(segment) {
				return segment.getLength();
			})
		},
<span id='App-dynamic-Strand-method-getSegmentwiseStructure'>		/**
</span>		 * Returns the structure of the strand, representing each segment
		 * as a single unit/character. See #getStructure
		 * to get the structure with each base represented by one character.
		 * @return {App.dynamic.Structure} structure
		 */
		getSegmentwiseStructure: function() {
			return this.structure;	
		},
		getAnnotatedStructure: function() {
			var n = -1, segs = this.getSegments();
			return _.map(this.structure.toDotParen().split(''),function(ch) {
				if(ch!='+') {
					n++;
					return {type: ch, segment: segs[n], length: segs[n].getLength()};
				} else {
					return {type: ch}
				}
			});
		},
<span id='App-dynamic-Strand-method-getStructure'>		/**
</span>		 * Returns the structure of the strand, representing each base
		 * as a single unit/character. See #getSegmentwiseStructure
		 * to get the structure with each segment represented by one character.
		 * @return {App.dynamic.Structure} structure
		 */
		getStructure : function() {
			return this.structure.expand(this.getSegmentLengths());
			
				// var duplex = false, lastDuplex = false, regionLength = 0, out = [];
// 				
				// // This code isn't right
				// _.each(this.getSegments(),function(segment) {
// 					
// 					
					// if(!!segment.duplex != duplex) {
						// if(regionLength &gt; 0) {						
							// out.push((duplex ? 'D' : 'U') +regionLength);
// 							
							// // silence the next duplex 
							// if(duplex) {
								// lastDuplex = !lastDuplex;								
							// }
						// }
						// duplex = !duplex;
						// regionLength = 0;
					// }
// 
					// if(!!segment.duplex == duplex) {
						// if(duplex &amp;&amp; lastDuplex) {
							// return;
						// }
						// regionLength += segment.getLength();
					// }
// 					
				// });
// 				
				// // Finish the remaining segment
				// if(regionLength &gt; 0) {
					// out.push((duplex ? 'D' : 'U') +regionLength);
				// }
// 				
				// return out.join(' ')				
		},
		orphan: function() {
			this.polarity = this.getAbsolutePolarity();
			delete this.node;
			return this;
		},
		serialize: function() {
			var out = _.copy(this);
			if(out.node) { delete out.node }
			if(out.library) { delete out.library; }
			return _.serialize(out);
		},
	}

	/* ***************************************************************** */

<span id='App-dynamic-Domain'>	/**
</span>	 * @class App.dynamic.Domain
	 * Represents a domain, which is a collection of {@link App.dynamic.Segment}s
	 * within a {@link App.dynamic.Node node} or {App.dynamic.Motif motif}.
	 */
	function Domain(config) {
		if(!config.library) {
			throw new DynamlError({
				type: 'no library',
				message: 'domain instantiated without library reference',
				domain: this,
				config: config,
			});
		}
		
		// Apply configuration options with defaults to this object
		_.copyTo(this, config), _.defaults(this, {
			segments : [],
		});

<span id='App-dynamic-Domain-property-segments'>		/**
</span>		 * @property {App.dynamic.Segment[]} segments
		 * @private
		 */

		// Construct Segment objects from specification
		this.segments = _.map(this.segments, function(segment) {
			segment = _.copyWith(segment, {
				domain : this, 
				library : this.library,
			});
			return new Segment(segment);
		}, this);
<span id='App-dynamic-Domain-property-polarity'>		/**
</span>		 * @property {Number} polarity
		 */
		this.polarity = DNA.parsePolarity(this.polarity);
	}


	Domain.prototype = {
		role : &quot;structural&quot;,
<span id='App-dynamic-Domain-method-getAbsolutePolarity'>		/**
</span>		 * Returns the absolute polarity of this domain
		 * absolute polarity = (domain relative polarity) * (strand relative polarity) * (node polarity)
		 * @return {Number} Abs. polarity
		 */
		getAbsolutePolarity : function() {
			return this.getPolarity() * this.getStrand().getPolarity() * this.getNode().getPolarity();
		},
<span id='App-dynamic-Domain-method-getSegments'>		/**
</span>		 * Retrieves the segments associated with this domain
		 * @returns {App.dynamic.Segment[]} segments
		 */
		getSegments : function() {
			return this.segments;
		},
<span id='App-dynamic-Domain-method-getStrand'>		/**
</span>		 * Retrieves the strand of which this domain is a part
		 * @return {App.dynamic.Strand}
		 */
		getStrand : function() {
			return this.strand;
		},
<span id='App-dynamic-Domain-method-getNode'>		/**
</span>		 * @return {Node} node The node which contains this domain.
		 */
		getNode : function() {
			return this.getStrand().getNode();
		},
<span id='App-dynamic-Domain-method-getName'>		/**
</span>		 * Gets the name of the domain
		 * @return {String} name
		 */
		getName : function() {
			return this.name;
		},
<span id='App-dynamic-Domain-method-getPolarity'>		/**
</span>		 * Returns the relative polarity of this domain
		 */
		getPolarity : function() {
			return this.polarity;
		},
		serialize: function() {
			var out = _.copy(this);
			if(out.strand) { delete out.strand }
			if(out.node) { delete out.node }
			if(out.library) { delete out.library; }
			return _.serialize(out);
		},
		
	};

	/* ***************************************************************** */

<span id='App-dynamic-Segment'>	/**
</span>	 * @class App.dynamic.Segment
	 * Smallest individual unit of sequence organization.
	 *
	 * # ID, identity, identifier
	 *
	 * -	Segment ID : a unique code assigned to each App.dynamic.Segment
	 * 	object, which allows the particular Segment to be looked up and
	 * 	identified unambiguously within the ensemble
	 * -	Identity : the particular name or label which this segment represents.
	 * 	Two segments with the same identity and the same polarity have
	 * 	identical sequences. Two segments with the same identity and the
	 * 	opposite polarity have complementary sequences
	 * -	Identifier : The identity of a sequence plus its polarity. Two
	 * 	segments with the same identifier have identical sequences.
	 */
	/*
	 * @constructor
	 * @param {Object} config
	 */
	function Segment(config) {
		_.copyTo(this, config);
		_.defaults(this, {
<span id='App-dynamic-Segment-cfg-segmentLength'>			/**
</span>			 * @cfg
			 * The length of this segment. If unspecified and #sequence is
			 * specified, this field will be updated to match.
			 */
			segmentLength : 6,
<span id='App-dynamic-Segment-cfg-role'>			/**
</span>			 * @cfg
			 * One of: `&quot;toehold&quot;`, `&quot;clamp&quot;`, `&quot;loop&quot;`, or `&quot;reverse&quot;`.
			 */
			role : &quot;toehold&quot;,
<span id='App-dynamic-Segment-cfg-sequence'>			/**
</span>			 * @cfg
			 */
			sequence : '',
		});
		if(this.sequence) {
			this.segmentLength = this.sequence.length;
		}

		if(this.name &amp;&amp; !this.identity) {
			_.extend(this, DNA.parseIdentifier(this.name));
		}
		this.id = Segment.getId();
		this.getLibrary().register('segment',this.id, this);
	}


	Segment.prototype = {
<span id='App-dynamic-Segment-method-getId'>		/**
</span>		 * Returns the unique ID assigned to this segment. This is distinct
		 * from the identity or identifier. See {@link App.dynamic.Segment class description}.
		 */
		getId : function() {
			if(!this.id) {
				this.id = Segment.getId();
			}
			return this.id;
		},
<span id='App-dynamic-Segment-method-getName'>		/**
</span>		 * Gets the original name of the Segment
		 */
		getName : function() {
			return this.name;
		},
<span id='App-dynamic-Segment-method-getFullName'>		/**
</span>		 * Gets the original name of the segment, qualified by the name of the
		 * parent {@link App.dynamic.Domain domain} and {@link App.dynamic.Node node}.
		 *
		 * @return {String} fullName In the form [node name].[domain name].[segment name]
		 */
		getFullName : function() {
			var domain = this.getDomain(), node = this.getNode();

			return [node.getName(), domain.getName(), this.getName()].join('.')
		},
<span id='App-dynamic-Segment-method-getQualifiedName'>		/**
</span>		 * Returns the identity portion of the original {@link #getName name}, qualified
		 * with a polarity.
		 */
		getQualifiedName : function() {
			return DNA.makeIdentifier(DNA.normalizeIdentity(this.name), this.polarity);
		},
<span id='App-dynamic-Segment-method-getIdentity'>		/**
</span>		 * Returns the identity of this segment
		 */
		getIdentity : function() {
			return this.identity;
		},
<span id='App-dynamic-Segment-method-getIdentifier'>		/**
</span>		 * Returns the identifier (segment + polarity specifier) for this segment
		 */
		getIdentifier : function(name, polarity) {
			return this.identity + ((this.polarity == -1) ? DNA.defaultPolaritySpecifier : '');
		},
<span id='App-dynamic-Segment-method-getNode'>		/**
</span>		 * @return {Node} node The node which contains this segment
		 */
		getNode : function() {
			return this.getDomain().getNode();
		},
<span id='App-dynamic-Segment-method-getDomain'>		/**
</span>		 * @return {Domain} domain The domain which contains this segment
		 */
		getDomain : function() {
			return this.domain;
		},
		getAbsolutePolarity : function() {
			var nodePolarity = this.getNode().polarity, domainPolarity = this.getDomain().polarity;
			return nodePolarity * domainPolarity * this.polarity;
		},
<span id='App-dynamic-Segment-method-getSequence'>		/**
</span>		 * Gets the sequence (or degenerate sequence) of this segment
		 */
		getSequence : function() {
			if(this.sequence &amp;&amp; this.sequence.length == this.segmentLength) {
				return this.sequence;
			} else {
				return (new Array(this.segmentLength + 1)).join('N');
			}
		},
<span id='App-dynamic-Segment-method-getLength'>		/**
</span>		 * Gets the length of this segment in nucleotides
		 */
		getLength : function() {
			return (this.sequence ? this.sequence.length : this.segmentLength);
		},
<span id='App-dynamic-Segment-method-duplicate'>		/**
</span>		 * Returns a copy of this Segment's salient (non-prototype) properties
		 */
		duplicate : function() {
			return _.copy(this);
		},
		serialize: function() {
			var out = _.copy(this);
			if(out.strand) { delete out.strand }
			if(out.domain) { delete out.domain }
			if(out.node) { delete out.node }
			if(out.library) { delete out.library; }
			return _.serialize(out);
		},
		getLibrary: function() {
			return this.library;
		}
	}

	_.extend(Segment, {
		segments : {},
		register : function(id, segment) {
			this.segments[id] = segment;
			return segment;
		},
		get : function(id) {
			if( id instanceof Segment) {
				return id;
			} else {
				return this.segments[id];
			}
		},
<span id='App-dynamic-Segment-static-method-getId'>		/**
</span>		 * Returns the next unique segment ID
		 * @static
		 */
		getId : function() {
			var count = 0;
			return function() {
				count++;
				return &quot;segment_&quot; + count;
			}
		}()
	})

	/* ***************************************************************** */
		
<span id='App-dynamic-Structure'>	/**
</span>	 * @class App.dynamic.Structure
	 * Represents a secondary structure of a motif or node
	 */
	function Structure(config) {
		var spec, type;
		if(_.isString(config)) {
			spec = config;
			if(spec.match('.')) {
				type = 'dot-paren';
			} else if(spec.match(/[DHU]+/gi)) {
				spec = spec.replace('H','D');
				type = 'DU+';
			}
			config = {
				spec: spec,
				type: type,
			};
		}
<span id='App-dynamic-Structure-property-spec'>		/**
</span>		 * @property {String} spec
		 */
<span id='App-dynamic-Structure-property-type'>		/**
</span>		 * @property {String} type
		 * One of &quot;dot-paren&quot; or &quot;DU+&quot;
		 */
		_.copyTo(this, config);
		_.defaults(this, {});
	}
	
	_.extend(Structure.prototype,{
		toDotParen: function() {
			if(this.type=='dot-paren') {
				return this.spec;				
			} else {
				throw new DynamlError({
					type: 'unimplemented',
				});
			}
		},
		reverse: function() {
			if(this.type=='dot-paren') {
				return new Structure(_.chain(this.spec.split('')).reverse().map(function(ch) { 
					if(ch=='(') return ')' 
					else if(ch==')') return '('
					else return ch
				}).value().join(''));
			} else {
				throw new DynamlError({
					type: 'unimplemented',
				});
			}
		},
		expand: function(lengths) {
			var spec = this.spec, out = [], len, ch;
			if(lengths.length != spec.length) {
				throw new DynamlError({
					type: &quot;structure size mismatch&quot;,
					structure: spec,
					lengths: lengths,
				});
			}
			for(var i=0;i&lt;lengths.length;i++) {
				len = lengths[i];
				ch = spec[i];
				out.push(Array(len+1).join(ch));
			}
			return new Structure(out.join(''));
		}
	});
	
	_.extend(Structure,{
		parseMultiple: function(o) {
			if(_.isObject(o)) {
				var spec = o.spec || '',
					specs = spec.split('+');
				
				if(o.order) {
					specs = _.reduce(o.order,function(memo,destinationIndex,specIndex) {
						memo[index] = new Structure(specs[specIndex]);
						return memo;
					},{});
					return specs;
				}
			} else {
				specs = o.split('+');
			}
			return _.map(specs,function(spec) {
				return new Structure(spec);
			})
		},
		parseDUPlus: function(spec) {
			
		},
		DUtoDotParen: function(spec) {
			
		},
		dotParenToDU: function(spec) {
			var ch = '', count=0, out = [];
			while(spec.length &gt; 0) {
				if(ch != spec[0]) {
					out.push(Array(count+1).join(ch));
				} else {
					n++;
				}
				Array.prototype.shift.apply(spec);
			}
			out.push(Array(count+1).join(ch));
			return out.join('');
		},
		join: function(structures) {
			return new Structure(_.map(structures,function(struct) {
				return struct.toDotParen();
			}).join('+'));
		}
	})

	/* ***************************************************************** */

<span id='App-dynamic-Complement'>	/**
</span>	 * @class App.dynamic.Complement
	 * Represents a complementarity between two ports
	 */
	/*
	 * @constructor
	 * @param {Object} config
	 */
	function Complement(config) {
		this.library = config.library;
		if(!config.library) {
			throw new DynamlError({
				type: 'no library',
				message: 'complement instantiated without library reference; can\'t decode node references',
				complement: this,
				complements: [this],
				config: config,
			});
		}
		
<span id='App-dynamic-Complement-cfg-sourceNode'>		/**
</span>		 * @cfg {String/App.dynamic.Node} sourceNode
		 * Name or reference to the node which will become #property-sourceNode
		 */
<span id='App-dynamic-Complement-property-sourceNode'>		/**
</span>		 * @property {App.dynamic.Node} sourceNode
		 */
		this.sourceNode = this.library.getNode(config.sourceNode);
<span id='App-dynamic-Complement-cfg-node'>		/**
</span>		 * @cfg {String/App.dynamic.Node} node
		 * Name or reference to the node which will become #property-targetNode
		 */
<span id='App-dynamic-Complement-property-targetNode'>		/**
</span>		 * @property {App.dynamic.Node} targetNode
		 */
		this.targetNode = this.library.getNode(config.node);

<span id='App-dynamic-Complement-cfg-source'>		/**
</span>		 * @cfg {String} source
		 * Name of the {@link App.dynamic.Domain domain} which will become #property-sourcePort
		 */
<span id='App-dynamic-Complement-property-sourcePort'>		/**
</span>		 * @property {String} sourcePort
		 */
		this.sourcePort = this.sourceNode ? this.sourceNode.getDomain(config.source) : null;
<span id='App-dynamic-Complement-cfg-target'>		/**
</span>		 * @cfg {String} target
		 * Name of the {@link App.dynamic.Domain domain} which will become #property-targetPort
		 */
<span id='App-dynamic-Complement-property-targetPort'>		/**
</span>		 * @property {String} targetPort
		 */
		this.targetPort = this.targetNode ? this.targetNode.getDomain(config.target) : null;

		// Throw errors if anything is wrong.
		if(this.sourceNode == null) {
			throw new DynamlError({
				type : 'phantom complement',
				message : 'Complementarity generated with no sourceNode',
				config : config,
				sourceNode : config.sourceNode,
				targetNode : config.node,
				sourcePort : config.source,
				targetPort : config.target,
				nodes: [config.sourceNode, config.targetNode],
				ports: [config.source, config.target],
				complements: [this],
			})
		}
		if(this.targetNode == null) {
			throw new DynamlError({
				type : 'invalid complement',
				message : 'In complement from Node &lt;%= sourceNode %&gt;, target node &lt;%= targetNode %&gt;, was not found.',
				sourceNode : config.sourceNode,
				targetNode : config.node,
				sourcePort : config.source,
				targetPort : config.target,
				nodes: [config.sourceNode, config.targetNode],
				ports: [config.source, config.target],
				complements: [this],
			});
		}
		if(this.sourcePort == null) {
			throw new DynamlError({
				type : 'invalid complement',
				message : 'In complement between Node &lt;%= sourceNode %&gt; and Node &lt;%= targetNode %&gt;, source port &lt;%= sourcePort %&gt; not found.',
				sourceNode : config.sourceNode,
				targetNode : config.node,
				sourcePort : config.source,
				targetPort : config.target,
				nodes: [config.sourceNode, config.targetNode],
				ports: [config.source, config.target],
				complements: [this],
			});
		}
		if(this.targetPort == null) {
			throw new DynamlError({
				type : 'invalid complement',
				message : 'In complement between Node &lt;%= sourceNode %&gt; and Node &lt;%= targetNode %&gt;, target port &lt;%= targetPort %&gt; not found.',
				sourceNode : config.sourceNode,
				targetNode : config.node,
				sourcePort : config.source,
				targetPort : config.target,
				nodes: [config.sourceNode, config.targetNode],
				ports: [config.source, config.target],
			});
		}
	}


	Complement.prototype = {
<span id='App-dynamic-Complement-method-getSourceDomain'>		/**
</span>		 * Returns the port/domain on the #sourceNode on which this Complement operates
		 */
		getSourceDomain : function() {
			return this.sourcePort;
		},
<span id='App-dynamic-Complement-method-getSourcePort'>		/**
</span>		 * Returns the port/domain on the #sourceNode on which this Complement operates
		 */
		getSourcePort : function() {
			return this.sourcePort;
		},
<span id='App-dynamic-Complement-method-getTargetDomain'>		/**
</span>		 * Returns the port/domain on the #targetNode on which this Complement operates
		 */
		getTargetDomain : function() {
			return this.targetPort;
		},
<span id='App-dynamic-Complement-method-getTargetPort'>		/**
</span>		 * Returns the port/domain on the #targetNode on which this Complement operates
		 */
		getTargetPort : function() {
			return this.targetPort;
		},
<span id='App-dynamic-Complement-method-getType'>		/**
</span>		 * Returns the type of this relationship, either `output` or `bridge`
		 */
		getType: function() {
			if(this.getTargetPort().role == 'input' &amp;&amp; this.getSourcePort().role == 'output') {
				return 'output';
			}
			if(this.getTargetPort().role == this.getSourcePort().role == 'bridge') {
				return 'bridge';
			}
		},
		serialize: function() {
			var out = _.copy(this);
			if(out.strand) { delete out.strand }
			if(out.domain) { delete out.domain }
			if(out.node) { delete out.node }
			if(out.library) { delete out.library; }
			return _.serialize(out);
		}
	}

	/* ***************************************************************** */

<span id='App-dynamic-DynamlError'>	/**
</span>	 * @class App.dynamic.DynamlError
	 * Class for representing general errors which may occur during the course
	 * of DyNAML system compilation.
	 */
	/*
	 * @constructor
	 * @param {Object} config
	 */
	function DynamlError(config) {
<span id='App-dynamic-DynamlError-cfg-message'>		/**
</span>		 * @cfg {String} message
		 * A human-readable message which contains information about the error
		 * which has occured. This message may optionally be a template
		 * containing EJS (`&lt;% arbitrary code %&gt;` or `&lt;%= variable %&gt;`) tags,
		 * which will be interpolated by _#template. The scope used will be
		 * the configuration object passed to the #constructor
		 *
		 */
		if(config.message) {
			config.message = _.template(config.message, config);
		}
		_.copyTo(this, config);
	}
	
	DynamlError.prototype.serialize = function() {
		return _.serialize(_.copy(this));
	}
	
	/* ***************************************************************** */

<span id='App-dynamic-Library'>	/**
</span>	 * @class App.dynamic.Library
	 * Represents a collection of {@link App.dynamic.Motif motifs} and
	 * {@link App.dynamic.Node nodes} which can be compiled into 
	 * {@link App.dynamic.Strand strands}. Creating a new library object
	 * does not automatically compile the system; instead, you should either
	 * call the #compile method of this class, or use App.dynamic.Compiler
	 */
	function Library(config) {
		
		_.copyTo(this,config);
		
		// necessary to avoid weird bugs with the UI since these objects are modified
		this.motifs = _.clone(this.motifs);
		this.nodes = _.clone(this.nodes);
		this['import'] = _.clone(this['import']);
		
		_.defaults(this, {
<span id='App-dynamic-Library-cfg-motifs'>			/**
</span>			 * @cfg {Object[]/App.dynamic.Motif[]} motifs
			 * Array of {@link App.dynamic.Motif motifs} or motif configuration
			 * objects
			 */
<span id='App-dynamic-Library-property-motifs'>			/**
</span>			 * @property {App.dynamic.Motif[]} motifs
			 */
			motifs : [],
<span id='App-dynamic-Library-cfg-nodes'>			/**
</span>			 * @cfg {Object[]/App.dynamic.Node[]} nodes
			 * Array of {@link App.dynamic.Node nodes} or node configuration
			 * objects
			 */
<span id='App-dynamic-Library-property-nodes'>			/**
</span>			 * @property {App.dynamic.Node[]} nodes
			 */
			nodes : [],
<span id='App-dynamic-Library-cfg-import'>			/**
</span>			 * @cfg {Object[]} import
			 */
			'import' : [],
			objects: {
				node: {},
				motif: {},
				segment: {},
			}
		});
	}
	
	Library.prototype = {
		getNode: function(name) {
			if(name instanceof Node) return name;
			return this.objects['node'][name];
		},
		getMotif: function(name) {
			if(name instanceof Motif) return name;
			return this.objects['motif'][name];
		},
		getSegment: function(name) {
			if(name instanceof Segment) return name;
			return this.objects['segment'][name];
		},
		register: function(type,name,object) {
			if(!this.objects[type][name]) {
				this.objects[type][name] = object;
			} else {
				throw new DynamlError({
					type: 'duplicate object',
					message: 'Attempt to define &lt;%= kind %&gt; &lt;%= name %&gt; twice in same library',
					kind: type,
					name: name,
					original: this.objects[type][name],
					second: object,
				});
			}
		},
		get: function(type,name) {
			return this.objects[type][name];
		},
		
<span id='App-dynamic-Library-method-compile'>		/**
</span>		 * Compiles this library to generate #strands, #segments, etc.
		 */
		compile: function() {
			return Compiler.compileLibrary(this);
		},
<span id='App-dynamic-Library-method-printStrands'>		/**
</span>		 * @inheritdoc App.dynamic.Compiler#printStrands
		 */
		printStrands: function(config) {
			return Compiler.printStrands(this,config);
		},
		
		// toNupackOutput: function() {
// 			
			// var library = this;
// 
			// var out = [];
// 			
			// // TODO: Add custom parameters
			// // material = dna
			// // temperature[C] = 23.0 # optional units: C (default) or K
			// // trials = 3
			// // sodium[M] = 1.0       # optional units: M (default), mM, uM, nM, pM
			// // dangles = some
// 			
// 			
			// // print domains (segments)
			// // e.g.: domain x = N7
// 			
			// function nupackifyIdentity(id) {
				// return 'd'+id;
			// }
// 			
			// out.push(_.map(library.segments,function(segment) {
				// return ['domain',nupackifyIdentity(segment.identity),'=',segment.getSequence()].join(' ');
			// }).join('\n'));
// 			
			// // print strands (&quot;optional?&quot;)
			// // e.g.: strand J = gate_toehold1* gate_duplex1* gate_toehold2
			// // TODO: new NUPACK requires these not to be numbers... poo; need to letter domains.
// 			
			// out.push(_.map(library.strands,function(strand) {
				// return ['strand',strand.getQualifiedName(),'='].concat(_.map(strand.getSegments(),function(segment) {
					// return nupackifyIdentity(segment.getIdentifier());
				// })).join(' ');
			// }).join('\n'));
// 			
			// // print structures
			// // e.g.: structure gate_full = D30(+D30(U6+))
			// // e.g.: structure haripin = Ux Hx Ux Ux
// 			
			// out.push(_.map(library.strands,function(strand) {
				// var struct = strand.getStructure();
				// if(strand.getAbsolutePolarity == -1) {
					// struct = struct.reverse();
				// }
				// return ['structure',strand.getQualifiedName()+'_structure','=',struct.toDotParen()].join(' ');
			// }).join('\n'));
// 			
			// // thread sequences onto structures 
			// // e.g.: gate_full.seq = E G F
// 			
			// out.push(_.map(library.strands,function(strand) {
				// return [strand.getQualifiedName()+'_structure.seq','=',strand.getQualifiedName()].join(' ');
			// }).join('\n'));
// 			
			// return out.join('\n\n');
// 			
		// },
		toNupackOutput: function() {
			
			var library = this;

			var out = [];
			
			// TODO: Add custom parameters
			// material = dna
			// temperature[C] = 23.0 # optional units: C (default) or K
			// trials = 3
			// sodium[M] = 1.0       # optional units: M (default), mM, uM, nM, pM
			// dangles = some
			
			
			// print domains (segments)
			// e.g.: domain x = N7
			
			function nupackifyIdentity(id) {
				return 'd'+id;
			}
			
			out.push(_.map(library.segments,function(segment) {
				return ['domain',nupackifyIdentity(segment.identity),'=',segment.getSequence()].join(' ');
			}).join('\n'));
			
			// print strands (&quot;optional?&quot;)
			// e.g.: strand J = gate_toehold1* gate_duplex1* gate_toehold2
			// TODO: new NUPACK requires these not to be numbers... poo; need to letter domains.
			
			out.push(_.map(library.strands,function(strand) {
				return ['strand',strand.getQualifiedName(),'='].concat(_.map(strand.getSegments(),function(segment) {
					return nupackifyIdentity(segment.getIdentifier());
				})).join(' ');
			}).join('\n'));
			
			// print structures
			// e.g.: structure gate_full = D30(+D30(U6+))
			// e.g.: structure haripin = Ux Hx Ux Ux
			
			out.push(_.map(library.nodes,function(node) {
				
				var structs = _.map(node.getStrands(),function(strand) { 
					var struct = strand.getStructure();
					if(strand.getAbsolutePolarity() == -1) {
						struct = struct.reverse();
					}
					return struct;
				});
				
				var concatamer = Structure.join(structs);
				
				return ['structure',node.getName()+'_structure','=',concatamer.toDotParen()].join(' ');
			}).join('\n'));
			
			// thread sequences onto structures 
			// e.g.: gate_full.seq = E G F
			
			out.push(_.map(library.nodes,function(node) {
				var names = _.map(node.getStrands(),function(strand) {
					return strand.getQualifiedName();
				});
				return [node.getName()+'_structure.seq','='].concat(names).join(' ');
			}).join('\n'));
			
			return out.join('\n\n');
			
		},
		toDomainsOutput: function() {
			return Compiler.printStrands(this,{annotations: false});
		},
		toSVGOutput: function() {
			String.prototype.format = function() {
			  var args = arguments;
			  return this.replace(/{(\d+)}/g, function(match, number) { 
			    return typeof args[number] != 'undefined'
			      ? args[number]
			      : match
			    ;
			  });
			};
			
			var fid = {
				out: [],
				write: function(x) {
					this.out.push(x)
				},
				close: function() {
					return this.out.join('');
				}
			}
			
			var pi = Math.PI;
			var atan2 = Math.atan2;
			
			var x = 0,
			y = 0,
			H=300,
			V=160,
			// space allocated for each motif to be drawn in (one tile)
			R = Math.round(Math.sqrt(this.strands.length)),
			C = Math.ceil(this.strands.length/R);
			
			fid.write('&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;\n&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;\n'+
			'&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;\nviewBox = &quot;0 0 ' + repr(H*C) + ' ' + repr(V*R) + '&quot; version = &quot;1.1&quot;&gt;\n'+
			'&lt;defs&gt;&lt;path id=&quot;arrow&quot; d=&quot;M -7 -7 L 0 0 L -7 7&quot;/&gt;\n&lt;/defs&gt;\n'+
			'&lt;style type=&quot;text/css&quot;&gt;text { font-family: tahoma, helvetica, arial; }&lt;/style&gt;')

			for(var svgi = 0; svgi &lt; this.strands.length; svgi++) {
				var strand = this.strands[svgi];
				
				 var structure = strand.getSegmentwiseStructure().toDotParen();
				
				if(structure.match(/^\.+$/)) { //initiator, straight strand without hybridization
					fid.write('&lt;g stroke = &quot;rgb(139,98,61)&quot; stroke-width = &quot;2&quot; fill = &quot;none&quot;&gt;\n&lt;path d = &quot;M {0} {1} L {2} {3}&quot;/&gt;\n'.format(x+H*.15,y+V*.5,x+H*.6,y+V*.5))
				    if (strand.getPolarity()==-1) 
				      fid.write('&lt;use x=&quot;{0}&quot; y=&quot;{1}&quot; xlink:href=&quot;#arrow&quot; transform=&quot;rotate(180,{2},{3})&quot;/&gt;\n'.format(x+H*.15,y+V*.5,x+H*.15,y+V*.5))
				    else
				      fid.write('&lt;use x=&quot;{0}&quot; y=&quot;{1}&quot; xlink:href=&quot;#arrow&quot;/&gt;\n'.format(x+H*.6,y+V*.5))
				    fid.write('&lt;/g&gt;\n&lt;g stroke=&quot;none&quot; fill=&quot;black&quot; font-size=&quot;16&quot;&gt;\n')
				    var segments = strand.getSegments();
				    for(var svgj = 0; svgj &lt; segments.length; svgj++) {
				      var s = segments[svgj].getIdentifier();
				      fid.write('&lt;text x=&quot;{0}&quot; y=&quot;{1}&quot; stroke=&quot;none&quot; fill=&quot;black&quot;&gt;{2}&lt;/text&gt;\n'.format(x+H*.15+H*(svgj+.5)/segments.length*.45,y+V*.5-V*.05,s))
				    }
				    fid.write('&lt;/g&gt;\n')
				} else if(structure.match(/^\.+\(+\.+\)+(\.+)?$/)) { //hairpin loop
			    	var segments = strand.getSegments();
					var a = structure.indexOf('(');  // number of first hybridized segment

				    var b = a;
				    while(structure[b]=='(') { b++ } // number of last hybridized segment
					b--;

				    c = structure.indexOf(')');  // number of first hybridized segment after wraparound
				    
				    var d = c; // number of last hybridized segment after wraparound
				    while(structure[d]==')') { d++ }
				    d--;
				    
				    var segmentLengths = strand.getSegmentLengths();
				    
				    function sum(ls) {
				    	return _.reduce(ls,function(m,x) {return m+x},0);
				    }
				    
				    var len1 = sum(segmentLengths.slice(0,a)),  // length of the initial toehold, in bases
				    len2 = sum(segmentLengths.slice(a,b+1)),  // length of the duplex region, in bases
				    len3 = sum(segmentLengths.slice(b+1,c)),  // length of the hairpin loop, in bases
				    len4 = sum(segmentLengths.slice(d+1));  // length of the trailing end, in bases


				    fid.write('&lt;g stroke = &quot;black&quot; stroke-width = &quot;1&quot; fill = &quot;none&quot;&gt;\n')
				    for(var svgj = 0; svgj &lt; len2; /*segments.length;*/ svgj++) { // draw cross-lines for paired bases
			      		fid.write('&lt;line x1 = &quot;{0}&quot; y1 = &quot;{1}&quot; x2 = &quot;{2}&quot; y2 = &quot;{3}&quot;/&gt;\n'.format(x+H*.3+H*.3*svgj/len2,y+V*.45,x+H*.3+H*.3*svgj/len2,y+V*.5))
				      }
			    	fid.write('&lt;/g&gt;\n')
			    	fid.write('&lt;g stroke = &quot;black&quot; stroke-width = &quot;2&quot; fill = &quot;none&quot;&gt;\n&lt;path d = &quot;M {0} {1} a {2} {3} 0 1 1 {4} {5} L {6} {7}&quot; stroke=&quot;black&quot;/&gt;\n'.format(x+H*.6,y+V*.45,H*.085,V*.25,0,V*.05,x+H*.3,y+V*.5))  // loop and bottom line
			    	fid.write('&lt;line x1 = &quot;{0}&quot; y1 = &quot;{1}&quot; x2 = &quot;{2}&quot; y2 = &quot;{3}&quot; stroke = &quot;rgb(241,139,17)&quot;/&gt;\n'.format(x+H*.15,y+V*.45,x+H*.6,y+V*.45))  // yellow top line
			    	if (len4&gt;0)
			      		fid.write('&lt;path d = &quot;M {0} {1} L {2} {3}&quot; stroke = &quot;black&quot;/&gt;\n'.format(x+H*.3,y+V*.5,x+H*.15,y+V*.8))  // trailing end
			    	if (strand.getPolarity() == -1) {
			      		fid.write('&lt;use x=&quot;{0}&quot; y=&quot;{1}&quot; stroke=&quot;rgb(241,139,17)&quot; xlink:href=&quot;#arrow&quot; transform=&quot;rotate(180,{2},{3})&quot;/&gt;\n'.format(x+H*.15,y+V*.45,x+H*.15,y+V*.45))  // yellow top arrow
			    	} else {
			    	
				      if (len4&gt;0)
				        fid.write('&lt;use x=&quot;{0}&quot; y=&quot;{1}&quot; xlink:href=&quot;#arrow&quot; transform=&quot;rotate({2},{3},{4})&quot;/&gt;\n'.format(x+H*.15,y+V*.8,90+180/pi*atan2(V*.3,H*.15),x+H*.15,y+V*.8))  // bottom arrow
				      else
				        fid.write('&lt;use x=&quot;{0}&quot; y=&quot;{1}&quot; xlink:href=&quot;#arrow&quot; transform=&quot;rotate(180,{2},{3})&quot;/&gt;\n'.format(x+H*.3,y+V*.5,x+H*.3,y+V*.5))
				    }
				    fid.write('&lt;/g&gt;\n&lt;g stroke=&quot;none&quot; fill=&quot;black&quot; font-size=&quot;16&quot;&gt;\n')
				    
				    
				    
				    labelx = []
				    labely = []
				    
				    
				   
				    function repr(x) {
				    	return x;
				    }
				    
				    function range(x) {
				    	return _.range(0,x);
				    }
				    
				    var cos = Math.cos, sin = Math.sin, pi = Math.PI;
				    
				    for (var svgj = 0; svgj &lt; a; svgj++) {
				      labelx.push(H*(.15 + .15*(svgj+.5)/a))
				      labely.push(V*.4)
				    }  // toehold
				    for (svgj = 0; svgj &lt; b+1-a; svgj++) {
				    	
				      labelx.push(H*(.3 + .3*(svgj+.5)/(b+1-a)))
				      labely.push(V*.4)
				    }  // duplex region
				    for (svgj = 0; svgj &lt; c-(b+1); svgj++) {
				    	
				      labelx.push(H*(.75 - .05*cos(2*pi*(svgj+.5)/(c-(b+1)))))
				      labely.push(V*(.45 - .25*sin(2*pi*(svgj+.5)/(c-(b+1)))))
				    }  // hairpin loop
				    for (svgj = 0; svgj &lt; b+1-a; svgj++) {
				    	
				      labelx.push(H*(.6 - .3*(svgj+.5)/(b+1-a)))
				      labely.push(V*.6)
				    }  // duplex region again
				    for (svgj = 0; svgj &lt; d+1-c; svgj++) {
				    	
				      labelx.push(H*(.3 - .15*(svgj+.5)/(d+1-c)))
				      labely.push(V*(.6 + .3*(svgj+.5)/(d+1-c)))
				    }  // trailing end
				    
				    for (var svgj = 0; svgj &lt; segments.length; svgj++) {
				      var segment = segments[svgj];
				      
				      var s = segment.getIdentifier();
				      // if (svgk&gt;0)
				        // s = repr(svgk)
				      // else
				        // s = repr(-svgk) + '*'
				      fid.write('&lt;text x=&quot;{0}&quot; y=&quot;{1}&quot; stroke=&quot;none&quot; fill=&quot;black&quot;&gt;{2}&lt;/text&gt;\n'.format(x+labelx[svgj],y+labely[svgj],s))
				    }
			    	fid.write('&lt;/g&gt;\n')
					

				}
			  fid.write('&lt;text x=&quot;{0}&quot; y=&quot;{1}&quot; style=&quot;font-size: 18px; font-weight: bold;&quot; stroke=&quot;none&quot;&gt;{2}&lt;/text&gt;\n'.format(x+H*.45, y+V*.9, strand.getQualifiedName()))
			  y += V
			  if (y&gt;=V*R) {			  	
			    y=0
			    x += H
			  }
			}

			fid.write('&lt;/svg&gt;\n')
			return fid.close()
			
		},
		toPilOutput: function() {
			return '';
		},
		toMotif: function() {
			var strands = _.map(this.strands,function(strand) {
				var newStrand = _.copy(strand);
				newStrand.domains = _.map(newStrand.domains || [],function(domain) {
					var newDomain = _.copy(domain);
					if(domain.expose) {
						_.extend(newDomain,domain.expose);
						delete newDomain.expose;
					} else {
						domain.role = 'structural';
					}
					if(newDomain.orphan) {
						newDomain.orphan();
					}
					if(newDomain.strand) delete newDomain.strand;
					if(newDomain.node) delete newDomain.node;
					return domain;
				});
				newStrand.polarity = strand.getAbsolutePolarity();
				delete newStrand.node;
				return newStrand; //.serialize();
			});
			return {strands: strands};
		}
	};
	
	_.extend(Library,{
<span id='App-dynamic-Library-method-dummy'>		/**
</span>		 * Returns a dummy Library for orphan motifs
		 */
		dummy: function() {
			return new App.dynamic.Library({});
		},
		fromMotif: function(motif) {
			var duplicate = _.copy(motif);
			delete duplicate.library;
			return new Library(duplicate);
		}
	});
	
	

	/* ***************************************************************** */
	// Do the actual compiling

<span id='App-dynamic-Compiler'>	/**
</span>	 * @class App.dynamic.Compiler
	 * Performs the business of compiling {@link App.dynamic.Library libraries} 
	 * into strands and segments. This class is the preferred method of generating
	 * {@link App.dynamic.Library libraries}.
	 * 
	 * The main entry-point method is #compile, which can be passed a JSON string
	 * and will attempt to compile it into a library, throwing 
	 * {@link App.dynamic.DynamlError DynamlErrors} upon failure.
	 * 
	 * @singleton
	 */
	var Compiler = (function() {
		
<span id='App-dynamic-Compiler-method-parse'>		/**
</span>		 * Parses a DyNAML string into JSON library configuration object. Throws 
		 * a {@link App.dynamic.DynamlError DynamlError} on failure.
		 * @param {String} jsonString A string-representation of a JSON DyNAML specification
		 * @returns {Object} library
		 */
		function parse(jsonString) {
			var input = jsonString, library;
			try {
				library = JSON.parse(input);
			} catch(e) {
				throw new DynamlError({
					type : e.type,
					message : 'Parsing error: ' + e.message,
					stack : e.stack,
				});
			}
			return library;
		}
		
<span id='App-dynamic-Compiler-method-compile'>		/**
</span>		 * Parses a DyNAML string into a library. Throws 
		 * a {@link App.dynamic.DynamlError DynamlError} on failure.
		 * @param {String} jsonString A string-representation of a JSON DyNAML specification
		 * @returns {App.dynamic.Library} library
		 */
		function compile(jsonString) {
			return compileLibrary(parse(jsonString));
		}
		
<span id='App-dynamic-Compiler-method-compileLibrary'>		/**
</span>		 * Compiles a {@link App.dynamic.Library library} configuration object 
		 * into a compiled library.
		 * @param {Object} libraryConfig
		 * @returns {App.dynamic.Library} library
		 */
		function compileLibrary(library) {

			if(library) {
				
				/* ************************************************************
				 * Set up library objects
				 * 
				 * This process generates nodes which properly inherit the 
				 * properties of defined or imported Motifs, as well as
				 * Complements which refer to instantiated Nodes.
				 * 
				 */
				
				library = new Library(library);
				
				// Import motifs first
				if(library['import']) {
					_.each(library['import'],function(statement) {
						if(statement.type &amp;&amp; statement.name) {
							switch(statement.type) {
								case 'motif':
									library.motifs.unshift(importObject(statement.type,statement.name));
									break;
								case 'node':
									library.nodes.unshift(importObject(statement.type,statement.name));
									break;
								default:
									break;
							}
						}
					},this);
				}

				// Instantiate motifs to Motif objects
				library.motifs = _.reduce(library.motifs, function(memo,motif) {
					motif = _.copyWith(motif,{
						library: library,
						//externalMotifs: memo,
					});
					memo.push(new Motif(motif))
					return memo;
				},[]);
				
				// Instantiate nodes to Node objects
				library.nodes = _.map(library.nodes, function(node) {
					if(node.polarity) {
						delete node.polarity;
					}
					node.library = library;
					return new Node(node);
				});
				
				// Generate array of Complement objects
				var complementarities = _.chain(library.nodes).map(function(node) {
					return _.map(node.complementarities || [], function(complement) {
						complement.sourceNode = node;
						complement.library = library;
						return new Complement(complement);
					});
				}).compact().flatten().value();

				/* ************************************************************
				 * Generate Node polarities. 
				 * 
				 * This process will be repeated until the polarities stop changing.
				 * This is necessary because multiple passes may be required to set the polarities of upstream
				 * nodes before they can propogate to downstream nodes.
				 */
				var changing;
				do {
					changing = false;

					// Traverse Complements to generate Node polarities
					_.each(complementarities, function(complement) {

						// If the sourceNode's polarity has been set
						if(complement.sourceNode.polarity != 0) {

							// Downstream node should have polarity opposite the sourcePort's absolute polarity
							// (absolute polarity) = (relative port polarity) * (relative strand polarity) * (node polarity)
							var targetPolarity = -1 * complement.sourcePort.polarity * complement.sourcePort.getStrand().getPolarity() * complement.sourceNode.polarity
							
							if(isNaN(targetPolarity)) {
								if(isNaN(complement.sourcePort.polarity)) {									
									throw new DynamlError({
										type: 'polarity unspecified',
										message: 'source port polarity is NaN',
										sourceNode: complement.sourceNode,
										sourcePort: complement.sourcePort,
										complement: complement,
										nodes: [config.sourceNode,],
										ports: [config.sourcePort,],
									});
								} else {
									throw new DynamlError({
										type: 'polarity unspecified',
										message: 'source node polarity is NaN',
										sourceNode: complement.sourceNode,
										sourcePort: complement.sourcePort,
										complement: complement,
										nodes: [config.sourceNode,],
										ports: [config.sourcePort,],
									})
								}
							}

							// If the targetNode already has a polarity and it's wrong, throw polarity error
							if(complement.targetNode.polarity != 0 &amp;&amp; complement.targetNode.polarity == -targetPolarity) {
								throw new DynamlError({
									type : 'polarity conflict',
									message : _.template('Complementarity statement in node &lt;%= source %&gt; implies node &lt;%= target %&gt; ' + 'should have polarity &lt;%= expected %&gt;, but instead it has polarity &lt;%= encountered %&gt;', {
										source : complement.sourceNode.name,
										target : complement.targetNode.name,
										expected : targetPolarity,
										encountered : -targetPolarity,
									}),
									nodes : [complement.sourceNode, complement.targetNode],
									sourceNode : complement.sourceNode,
									targetNode : complement.targetNode,
									sourcePort : complement.getSourcePort(),
									targetPort : complement.getTargetPort(),
									nodes: [complement.sourceNode,complement.targetNode],
									ports: [complement.getSourcePort(), complement.getTargetPort(),],
								});
							} else if(complement.targetNode.polarity == targetPolarity) {
								return;
							} else {
								// Else propogate polarity downstream
								complement.targetNode.polarity = targetPolarity;
								changing = true;
							}
						}
					});
				} while(changing)

				// Set polarity of all unspecified nodes to 1 or whatever
				_.each(library.nodes, function(node) {
					if(node.polarity == 0) {
						node.polarity = 1;
					}
				});
				
				/* ************************************************************
				 * Build constraint matrix (formerly &quot;cmat&quot;)
				 * 
				 * Assembles a constraint matrix for each Node by calling 
				 * Node#getConstraintMatrix, then _.reduce-ing them into a 
				 * single hash. 
				 * 
				 * The constraint matrix effectively a jagged two-dimensional 
				 * hash. The keys are Segment IDs (see App.dynamic.Segment#id)
				 * and the values indicate the relationship between two segments:
				 * 
				 *     1 =&gt; equal
				 *     -1 =&gt; complementary
				 *     0 =&gt; orthogonal
				 * 
				 * See Node#getConstraintMatrix for more detail
				 * 
				 */
				
				// Build constraint matrix by collecting node constraint matricies
				var constraints = _.reduce(library.nodes, function(constraints, node) {
					_.extend(constraints, node.getConstraintMatrix());
					return constraints;
				}, {});

				// Add complementarity constraints to constraint matrix
				_.each(complementarities, function(complement) {
					// clone so we can potentially flip later or mutate later
					var sourceSegments = _.clone(complement.getSourceDomain().getSegments());
					var targetSegments = _.clone(complement.getTargetDomain().getSegments());
					var complementType = complement.getType();
					
					// flip domains for output ports, but not for bridges
					if(complementType=='output') {
						
						if((complement.sourcePort.getStrand().getAbsolutePolarity() == complement.targetPort.getStrand().getAbsolutePolarity()) != (complement.sourceNode.polarity == complement.targetNode.polarity)) {
							throw 'wut';
						}
						
						if(complement.sourcePort.getStrand().getAbsolutePolarity() == complement.targetPort.getStrand().getAbsolutePolarity()) {
						//if(complement.sourceNode.polarity == complement.targetNode.polarity) {
							targetSegments.reverse();
						}
					}
					
					// Two complementary ports should have the same length
					if(sourceSegments.length != targetSegments.length) {

						// If there's just an extra clamp for outputs, that's okay
						if(complementType=='output' &amp;&amp; sourceSegments.length - targetSegments.length == 1 &amp;&amp; _.last(sourceSegments).role == 'clamp') {
							sourceSegments.pop();
						} else if(complementType=='output' &amp;&amp; targetSegments.length - sourceSegments.length == 1 &amp;&amp; _.last(targetSegments).role == 'clamp') {
							targetSegments.pop();

						} else {
							// Otherwise complain
							throw new DynamlError({
								type : 'domain length mismatch',
								message : _.template('Complementarity statement in node &lt;%= sourceNode %&gt; implies domain &lt;%= targetNode %&gt;.&lt;%= targetPort %&gt; ' + //
								'should have &lt;%= expected %&gt; segments, but instead it has &lt;%= encountered %&gt; segments', {
									sourceNode : complement.sourceNode.getName(),
									targetNode : complement.targetNode.getName(),
									targetPort : complement.targetPort.getName(),
									expected : sourceSegments.length,
									encountered : targetSegments.length,
								}),
								nodes : [complement.sourceNode, complement.targetNode],
								sourceNode : complement.sourceNode,
								targetNode : complement.targetNode,
								sourcePort : complement.getSourcePort(),
								targetPort : complement.getTargetPort(),
								ports : [complement.getSourcePort(),complement.getTargetPort(),],
								
							});
						}
					}

					// Merges happen left (source) to right (target)
					// For each segment in sourceSegments
					for(var i = 0; i &lt; sourceSegments.length; i++) {
						constraints[sourceSegments[i].getId()][targetSegments[i].getId()] = -1;
					}
				});
				
				/* ************************************************************
				 * Generate numerical segment identities
				 * 
				 * First generate a list (labels) mapping segment IDs to unique
				 * numerical segment identities. Then traverse the hash of 
				 * constraints and enforce each constraint by setting segments 
				 * to have equal or complementary identities. 
				 * 
				 */
				
				// labels will map segment IDs to the eventual numerical segment identities.
				var labels = ( function() {
					var i = 0;
					return _.reduce(_.keys(constraints), function(labels, segmentId) {
						i++;
						labels[segmentId] = -i;
						return labels;
					}, {});
				}());

				
				// Merge segment identities
				var changing;
				do {
					changing = false;

					// Merge segment identities
					_.each(constraints, function(leftSegmentConstraints, leftSegmentId) {
						_.each(leftSegmentConstraints, function(constraint, rightSegmentId) {

							// if no constraint
							if(Math.abs(constraint) != 1) {
								return;

								// If some constraint exists
							} else {

								// Preserve the lower segment ID
								var segments = _.sortBy([leftSegmentId, rightSegmentId], function(id) {
									return Math.abs(labels[id])
								});
								var segmentIdToRelabel = _.last(segments);
								var segmentIdToKeep = _.first(segments);

								var newLabel = null;

								// If segments must be equal
								if(constraint == 1) {

									// Ensure they're not already complementary
									if(labels[leftSegmentId] == -labels[rightSegmentId]) {
										var leftSeg = library.getSegment(leftSegmentId), rightSeg = library.getSegment(rightSegmentId);
										throw new DynamlError({
											type : 'equality conflict',
											message : &quot;Segments &lt;%= left %&gt; and &lt;%= right %&gt; should be equal, but they're already complementary!&quot;,
											left : leftSeg.getFullName(),
											right : rightSeg.getFullName(),
											leftSegment : leftSeg,
											rightSegment : rightSeg,
											nodes : [leftSeg.getNode(), rightSeg.getNode()],
										});
									} else if(labels[leftSegmentId] != labels[rightSegmentId]) {
										// Otherwise, the downstream label should equal the upstream label
										newLabel = labels[segmentIdToKeep];
									}

									// If segments must be complementary
								} else if(constraint == -1) {

									// Ensure they're not already equal
									if(labels[leftSegmentId] == labels[rightSegmentId]) {
										var leftSeg = library.getSegment(leftSegmentId), rightSeg = library.getSegment(rightSegmentId);
										throw new DynamlError({
											type : 'equality conflict',
											message : &quot;Segments &lt;%= left %&gt; and &lt;%= right %&gt; should be complementary, but they're already equal!&quot;,
											left : leftSeg.getFullName(),
											right : rightSeg.getFullName(),
											leftSegment : leftSeg,
											rightSegment : rightSeg,
											nodes : [leftSeg.getNode(), rightSeg.getNode()],
											// TODO: equality/complementarity conflict
										});
									} else if(labels[leftSegmentId] != -labels[rightSegmentId]) {

										// Otherwise, the downstream label should be opposite the upstream label
										newLabel = -Math.abs(labels[segmentIdToKeep]) * DNA.signum(labels[leftSegmentId]) * DNA.signum(labels[rightSegmentId]);
									}
								}

								// If segments don't already satisfy constraint
								if(newLabel != null) {

									// Find the segment IDs of all segments which will need to be relabeled
									var segmentIdsToRelabel = _.filter(_.keys(labels), function(segmentId) {
										return Math.abs(labels[segmentId]) == Math.abs(labels[segmentIdToRelabel]);
									});
									// Copy labels so we can change them all at once
									var tempLabels = _.clone(labels);

									// Update downstream segments.
									_.each(segmentIdsToRelabel, function(segmentId) {

										var segment = library.getSegment(segmentId);
										segment.identity = Math.abs(newLabel);
										segment.polarity = DNA.signum(newLabel);

										if(constraint == -1) {
											tempLabels[segmentId] = DNA.signum(labels[segmentId]) * newLabel;
										} else {
											tempLabels[segmentId] = newLabel;
										}
										changing = true;
									});
									labels = tempLabels;
								}
							}

						});
					});
				} while(changing);

				// Condense labels so that there are no skipped numbers
				labels = (function(labels) {
					var uniqLabels = _.chain(labels).values().map(Math.abs).uniq().value(), mapping = DNA.mapUnique(uniqLabels, 1);
					return _.reduce(labels, function(labels, label, segmentId) {
						labels[segmentId] = mapping[Math.abs(label)] * DNA.signum(label);
						return labels;
					}, {});
				})(labels);

				/* ************************************************************
				 * Generate output properties of compiled library
				 */

				// Build array of all Segment objects, assign Segment objects to their identity in labels
				library.allSegments = [];

				_.each(library.nodes, function(node) {
					_.each(node.getStrands(), function(strand) {
						_.each(strand.getSegments(), function(segment) {
							segment.identity = Math.abs(labels[segment.getId()]);
							segment.polarity = DNA.signum(labels[segment.getId()]);
							library.allSegments.push(segment);
						})
					});
					// _.each(node.getSegments(), function(segment) {
						// segment.identity = Math.abs(labels[segment.getId()]);
						// segment.polarity = DNA.signum(labels[segment.getId()]);
						// library.allSegments.push(segment);
					// })
				});
				
				// Build an array of new Segment objects, each representing a unique segment identity.
				// This is mostly for the benefit of output generators like DD or NUPACK which
				// need to generate a list of each unique segment in the ensemble
				library.segments = _.chain(library.allSegments).uniq(false, function(segment) {
					return segment.identity;
				}).map(function(segment) {
					var duplicate = segment.duplicate();
					
					// These new Segments are deliberately divorced from their 
					// original &quot;name&quot;, parent node, and polarity, since the purpose
					// of these objects is to describe each unique segment identity 
					// and its sequence, length, etc (salient properties for sequence
					// designers mostly). 
					delete duplicate.name;
					delete duplicate.node;
					delete duplicate.polarity;
					return new Segment(duplicate);
				}).value();

				// Build an array of strands with properly numbered segments.
				library.strands = _.chain(library.nodes).map(function(node) {
					return node.getStrands();
					
					// return _.map(node.getStrands(),function(strand) {
						// return new Strand(strand);
					// }); //new Strand(node);
				}).flatten().value();
			} else {
				library = {};
			}
			return library;
		}
		
<span id='App-dynamic-Compiler-method-printStrands'>		/**
</span>		 * Prints a textual description of a given library for sequence design
		 * @param {App.dynamic.Library} library
		 * @param {Object} [options]
		 * @param {Object} [options.annotations=true] True to display brackets around domains and to indicate strand/domain polarities
		 * @param {Object} [options.originalSegmentNames=false] True to use the original {@link App.dynamic.Segment#name segment names} in the strand descriptions
		 */
		function printStrands(library,options) {
			options = options || {};
			_.defaults(options,{
				annotations: true,
				originalSegmentNames : false,
			});
			var out = '';
	
			var defaultPolaritySpecifier = &quot;*&quot;;
			
			function makeIdentifier(name, polarity) {
				return name + ((polarity == -1) ? defaultPolaritySpecifier : '');
			}
			
			out += _.map(library.segments,function(segment) {
				return ['sequence', /*makeIdentifier(segment.identity,segment.polarity),*/ segment.getIdentifier(),':',segment.getSequence()].join(' ')
			}).join('\n');
			
			out += '\n';
			
			out += _.map(library.strands, function(strand) {
				var name = strand.getQualifiedName();
				var domains = _.clone(strand.getDomains());
				if(strand.getAbsolutePolarity() == -1) {
					domains = domains.reverse();
				}
				
				return _([			
					// leader
					options.annotations ? 'strand' : '', 
					
					name, 
					
					// strand polarity specifier
					(options.annotations ? (strand.getAbsolutePolarity() == -1 ? '-' : '+') : ''),
					
					':',
					
					].concat(_.map(domains, function(domain) {
					
						var segments = _.clone(domain.getSegments());
						if(strand.getAbsolutePolarity() == -1) {
							segments = segments.reverse();
						}
						
						return [
							// opening domain grouping bracket
							(options.annotations ? '[' : '')
							
							// segment body
							].concat(_.map(segments,function(segment) {				
								return options.originalSegmentNames ? segment.getQualifiedName() : segment.getIdentifier(); //makeIdentifier(segment.identity, segment.polarity);
							}))
							
							// closing bracket
							.concat([options.annotations ? ']'+(domain.polarity== -1 ? '-' : '+') : ''])
							
							// convert to string
							.join(' ');
						
				}, ''))).compact().join(' ');
			}).join('\n');
	
			return out;
		}
		
		function printStrandsFromArray(strands,options) {
			options = options || {};
			_.defaults(options,{
				annotations: true,
				originalSegmentNames : false,
			});
			var out = '';
	
			var defaultPolaritySpecifier = &quot;*&quot;;
			
			function makeIdentifier(name, polarity) {
				return name + ((polarity == -1) ? defaultPolaritySpecifier : '');
			}
			
			out += _.map(strands, function(strand) {
				var name = strand.getQualifiedName();
				var domains = _.clone(strand.getDomains());
				if(strand.getAbsolutePolarity() == -1) {
					domains = domains.reverse();
				}
				
				return _([			
					// leader
					options.annotations ? 'strand' : '', 
					
					name, 
					
					// strand polarity specifier
					(options.annotations ? (strand.getAbsolutePolarity() == -1 ? '-' : '+') : ''),
					
					':',
					
					].concat(_.map(domains, function(domain) {
					
						var segments = _.clone(domain.getSegments());
						if(strand.getAbsolutePolarity() == -1) {
							segments = segments.reverse();
						}
						
						return [
							// opening domain grouping bracket
							(options.annotations ? '[' : '')
							
							// segment body
							].concat(_.map(segments,function(segment) {				
								return options.originalSegmentNames ? segment.getQualifiedName() : segment.getIdentifier(); //makeIdentifier(segment.identity, segment.polarity);
							}))
							
							// closing bracket
							.concat([options.annotations ? ']'+(domain.polarity== -1 ? '-' : '+') : ''])
							
							// convert to string
							.join(' ');
						
				}, ''))).compact().join(' ');
			}).join('\n');
	
			return out;
		}
		
<span id='App-dynamic-Compiler-property-standardMotifs'>		/**
</span>		 * @property {Object} standardMotifs
		 * Hash containing configuration objects for each of the standard motifs, indexed by name.
		 */
		var standardMotifs = [{
				name: 'm1',
				type: 'initiator',
				structure: '..',
			    isInitiator: true,
			    domains: [{
			    	name: 'A',
			    	role: 'output',
			    	type: 'init',
			    	polarity: '+',
			    	segments: [
				      	{name: 'a', role: ''},
				        {name: 'b', role: ''},
			    	]
			    }]
			},{
				name: 'm2',
				type: 'initiator',
			    isInitiator: true,
			    structure: '...',
			    domains: [{
			    	name: 'A',
			    	role: 'output',
			    	type: 'init',
			    	polarity: '+',
			    	segments: [
				      	{name: 'a', role: ''},
				        {name: 'b', role: ''},
				        {name: 'c', role: ''},
			    	]
			    }]
			},{
				name: 'm3',
				type: 'hairpin',
				structure: '.(.)',
			    domains: [{
			    	name: 'A',
			    	role: 'input',
			    	polarity: '+',
			    	segments: [
				      	{name: 'a', role: 'toehold'},
				        {name: 'b', role: ''},
			    	]
			    },{
			    	name: 'B',
			    	role: 'output',
			    	type: 'loop',
			    	polarity: '-',
			    	segments: [
				      	{name: 'c', role: 'loop'},
				        {name: 'b*', role: ''},
			    	]
			    }]
			},{
				name: 'm4',
				type: 'hairpin',
				structure: '.((..))..',
			    domains: [{
			    	name: 'A',
			    	role: 'input',
			    	polarity: '+',
			    	segments: [
				      	{name: 'a', role: 'toehold'},
				        {name: 'b', role: ''},
				        {name: 'c', role: ''},
			    	]
			    },{
			    	name: 'B',
			    	role: 'output',
			    	type: 'loop',
			    	polarity: '-',
			    	segments: [
				      	{name: 'd', role: 'loop'},
				        {name: 'e', role: 'loop'},
				        {name: 'c*', role: ''},
			    	]
			    },{
			    	name: 'C',
			    	role: 'output',
			    	type: 'tail',
			    	polarity: '+',
			    	segments: [
				      	{name: 'b*', role: 'toehold'},
				        {name: 'f', role: ''},
				        {name: 'g', role: ''},
			    	]
			    }]	
			},{
				name: 'm5',
				type: 'hairpin',
				structure: '.((.)).',
			    domains: [{
			    	name: 'A',
			    	role: 'input',
			    	polarity: '+',
			    	segments: [
				      	{name: 'a', role: 'toehold'},
				        {name: 'b', role: ''},
				        {name: 'c', role: ''},
			    	]
			    },{
			    	name: 'B',
			    	role: 'bridge',
			    	type: 'loop',
			    	polarity: '+',
			    	segments: [
				      	{name: 'd', role: 'loop'},
			    	]
			    },{
			    	name: 'C',
			    	role: 'null',
			    	type: 'stem',
			    	polarity: '+',
			    	segments: [
				      	{name: 'b*', role: ''},
				        {name: 'c*', role: ''},
			    	]
			    }]	
			},{
				name: 'm6',
				type: 'hairpin',
				structure: '.((....))..',
			    domains: [{
			    	name: 'A',
			    	role: 'input',
			    	polarity: '+',
			    	segments: [
				      	{name: 'a', role: 'toehold'},
				        {name: 'b', role: ''},
				        {name: 'c', role: ''},
			    	]
			    },{
			    	name: 'B',
			    	role: 'bridge',
			    	type: 'loop',
			    	polarity: '+',
			    	segments: [
				      	{name: 'd', role: 'loop'},
			    	]
			    },{
			    	name: 'C',
			    	role: 'output',
			    	type: 'loop',
			    	polarity: '-',
			    	segments: [
				      	{name: 'e', role: 'loop'},
				      	{name: 'f', role: 'loop'},
				      	{name: 'g', role: 'loop'},
				      	{name: 'c*', role: 'loop'},
			    	]
			    },{
			    	name: 'D',
			    	role: 'output',
			    	type: 'tail',
			    	polarity: '+',
			    	segments: [
				      	{name: 'b*', role: 'toehold'},
				        {name: 'h', role: ''},
				        {name: 'i', role: ''},
			    	]
			    }]	
			},{
				name: 'm7',
				type: 'hairpin',
				structure: '.((..))..',
			    domains: [{
			    	name: 'A',
			    	role: 'input',
			    	polarity: '+',
			    	segments: [
				      	{name: 'a', role: 'toehold'},
				        {name: 'b', role: ''},
				        {name: 'c', role: ''},
			    	]
			    },{
			    	name: 'B',
			    	role: 'output',
			    	type: 'loop',
			    	polarity: '-',
			    	segments: [
				      	{name: 'd', role: 'loop'},
				      	{name: 'e', role: 'loop'},
				      	{name: 'c*', role: ''},
			    	]
			    },{
			    	name: 'C',
			    	role: 'bridge',
			    	type: 'stem',
			    	polarity: '+',
			    	segments: [
				      	{name: 'b*', role: 'toehold'},
						{name: 'e', role: ''},
				      	{name: 'f', role: ''},
			    	]
			    }]
			},{
				name: 'm8',
				type: 'hairpin',
				structure: '.((.))..',
			    domains: [{
			    	name: 'A',
			    	role: 'input',
			    	polarity: '+',
			    	segments: [
				      	{name: 'a', role: 'toehold'},
				        {name: 'b', role: ''},
				        {name: 'c', role: ''},
			    	]
			    },{
			    	name: 'B',
			    	role: 'bridge',
			    	type: 'loop',
			    	polarity: '+',
			    	segments: [
				      	{name: 'd', role: 'loop'},
				      	{name: 'c*', role: ''},
			    	]
			    },{
			    	name: 'C',
			    	role: 'output',
			    	type: 'tail',
			    	polarity: '+',
			    	segments: [
				      	{name: 'b*', role: ''},
				      	{name: 'e', role: ''},
				      	{name: 'f', role: ''},
			    	]
			    }]
			},{
				name: 'm9',
				type: 'hairpin',
				structure: '.((.))',
			    domains: [{
			    	name: 'A',
			    	role: 'input',
			    	polarity: '+',
			    	segments: [
				      	{name: 'a', role: 'toehold'},
				        {name: 'b', role: ''},
				        {name: 'c', role: ''},
			    	]
			    },{
			    	name: 'B',
			    	role: 'bridge',
			    	type: 'loop',
			    	polarity: '+',
			    	segments: [
				      	{name: 'd', role: 'loop'},
				      	{name: 'c*', role: ''},
			    	]
			    },{
			    	name: 'C',
			    	role: 'null',
			    	type: 'stem',
			    	polarity: '+',
			    	segments: [
				      	{name: 'b*', role: ''},
			    	]
			    }]
			},{	
				name: 'm1c',
				type: 'initiator',
			    isInitiator: true,
			    structure: '....',
			    domains: [{
			    	name: 'A',
			    	role: 'output',
			    	type: 'init',
			    	polarity: '+',
			    	segments: [
				      	{name: 'a', role: ''},
				        {name: 'w', role: 'clamp'},
				        {name: 'b', role: ''},
				        {name: 'x', role: 'clamp'},
			    	]
			    }]
			  }, {
				name: 'm19c',
				type: 'hairpin',
				structure: '.(((..)))',
				domains: [{
			    	name: 'A',
			    	role: 'input',
			      	polarity: '+',
			    	segments:  [
			      		{name: 'a', role: 'toehold'},
				      	{name: 'w', role: 'clamp'},
				        {name: 'b', role: 'reverse'},
				      	{name: 'x', role: 'clamp'},
			    	]
			   },{
				   name: 'B',
				   role: 'output',
				   polarity: '-',
				   segments: [
					   {name: 'y', role: 'clamp'},
					   {name: 'c', role: 'loop'},
					   {name: 'x*', role: 'clamp'},
					   {name: 'b*', role: 'toehold'},
					   {name: 'w*', role: 'clamp'},
				   ]
			   }]
			}
		];
		standardMotifs = _.reduce(standardMotifs,function(memo,motif) {
			memo[motif.name] = motif;
			return memo; 
		},{});
		
		var domainColors = {
			'init' : '#553300',
			'input' : 'orange',
			'output' : '#33ccff',
			'output.init' : '#553300', // init (brown)
			'output.loop' : '#33ccff', // blue
			'output.tail' : '#66ff33', // green
			'bridge' : '#ff1177',
			'bridge.loop' : '#ff1177', // pink
			'bridge.stem' : '#9900cc',
		}
		
		function importObject(type,name) {
			switch(type) {
				case 'motif': 
					if(standardMotifs[name]) {
						return standardMotifs[name];
					} else if (standardMotifs['m'+name]) {
						return standardMotifs['m'+name];
					} else {
						throw new DynamlError({
							type: 'undefined motif',
							name: name,
							message: &quot;Couldn't find imported motif '&lt;%= name %&gt;'&quot;
						});
					}
					// TODO: import from external files
			}
		}
		
		function getColor (domain) {
			if(domain.role &amp;&amp; domain.type) {
				return domainColors[[domain.role, domain.type].join('.')];
			}
			return domainColors[domain.role] || '#000';
		}
		
		return {
			compile: compile,
			compileLibrary: compileLibrary,
			parse: parse,
			printStrands: printStrands, 
			printStrandsFromArray: printStrandsFromArray,
			importObject : importObject,
			standardMotifs : standardMotifs,
			domainColors: domainColors,
			getColor : getColor,
		}

	})();

	return {
		Node : Node,
		Motif : Motif,
		Strand : Strand,
		Segment : Segment,
		Library : Library,
		Compiler : Compiler,
		DynamlError : DynamlError, 
		Structure : Structure,
	}

})(_,DNA);
</pre>
</body>
</html>
